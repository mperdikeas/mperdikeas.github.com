<head>
  <link type="text/css" rel="stylesheet" href="mperdikeasgithub.css"/>
  <link rel='icon' href='/knowledge-favicon.ico'/>
  <style>
   .step {
     font-weight: bold;
     background: gold;
     color: blue;
     }
  </style>
</head>
<body>
  <ol reversed class=main-list-items>
    <li>February 2025 &mdash; start/stop PostgreSQL 12 and find hostname and port</li>
    <p>
      Use the following commands to start/stop or get the status of a locally running PostgreSQL cluster (database server):
      <pre>
systemctl start postgresql.service
systemctl stop postgresql.service
systemctl status postgresql.service</pre>
    </p>
    <p>
      To find the hostname and port all I had to do, in my local installation at least,
      was connect as user <tt>postgres</tt>:
      <pre>psql postgres</pre>
      &mdash; and then run the <tt>\conninfo</tt> command:
      <br/>
      <img src='./postgresql.html.files/psql-conn-info-output.png'/>
    </p>
    <li>January 2025 &mdash; configure PostgreSQL 12 to use a <i>data directory</i> in some other location (disk)</li>
    <p>
      I used the procedure outlined below to move the data directory
      of my PostgreSQL 12 installation (on my <i>ThinkStation P320</i>
      machine running <tt>Ubuntu 20.04</tt>) to a second, much larger,
      disk as I needed to import a huge (~100GB) binary dump of some
      PostgreSQL database that wasn't going to fit in the current location
      of the <i>data directory</i>. The below procedure of course only
      relates the <i>data directory</i> migration part, not the importation
      part (which I fear will be a separate ordeal).
      In the procedure detailed below, I basically followed the instructions
      I found
      <a href='https://fitodic.github.io/how-to-change-postgresql-data-directory-on-linux'>here</a>
      (archived locally
      <a href='./postgresql.html.files/change-postgresql-data-directory.pdf'>here</a>
      ).
      The instructions were almost entiery accurate with three
      notable exceptions:
      <ul>
        <li>the instructions assume that the <i>config file</i>
          is located inside the <i>data directory</i>. This was not true
          in my case. I believe that <i>PostgreSQL 12</i> keeps the data
          directory and the location of the configuration files different
          in the default installation so perhaps the instructions I found
          were written with a different version of PostgreSQL in mind.
        </li>
        <li>
          It was not at all necessary to edit the file at:
          <tt>/lib/systemd/system/postgresql.service</tt>
        </li>
        <li>The <i>SELinux</i> part was not at all applicable (I don't even
        know what that is)</li>
      </ul>
    </p>
    <p>
      The steps I followed were:
      <ol>
        <li>Take note of the <i>config file</i> and the <i>data directory</i>
          locations. Do this by connecting to PostgreSQL with the <tt>postgres</tt> user doing <pre>pgsql postgres</pre> and then execute
          the following commands:<br/>
          <img src='./postgresql.html.files/change-postgresql-data-directory-step-1.png'/>
        </li>
        <li style="margin-top: 1em">stop the PostgreSQL server (cluster in PostgreSQL terminology)
          <pre>systemctl stop postgresql</pre>
        </li>
        <li>prepare the destination directory. In my case I executed
          the following commands:

          <pre>
mkdir /media/hddb/postgresql-12-data
sudo chown postgres:postgres /media/hddb/postgresql-12-data
sudo chmod 700 /media/hddb/postgresql-12-data/
rsync -av /var/lib/postgresql/12/main/ /media/hddb/postgresql-12-data/ </pre>
        </li>
        <li>copy over the existing <i>data directory</i> to its new location:
          <pre>
rsync -av /var/lib/postgresql/12/main/ /media/hddb/postgresql-12-data/</pre>          
        </li>
        <li>Change the <tt>data_directory</tt> parameter value in the
          <tt>postgresql.conf</tt> configuration file. The parameter
          was previously commented out (and so default value was used); I
          obviously set it to the new location:
          <pre>
$ cat /etc/postgresql/12/main/postgresql.conf | grep -i data_directory | grep -v ^#
data_directory = '/media/hddb/postgresql-12-data'</pre>
          <span class='nb'>NB:</span> the single quotes were actually entered in the config file
          &mdash; I am not 100% certain they were essential.<br/>
          <span class='nb'>NB2:</span> in constrast to the instructions I was following, as
          already mentioned above, in my case the <i>configuration</i> directory was in
          an entirely different subtree (<tt>/etc/postgresql/12/main/postgresql.conf</tt>)
          than the <i>data directory</i> (<tt>/var/lib/postgresql/12/main</tt>). So, in
          contrast to the instructions I was using as a guide, I changed the <tt>postgresql.conf</tt>
          file in the <u>existing</u> configuration location, and <b>not</b> in the new one
          (in the instructions the case was that the <i>configuration file</i> was
          located <u>inside</u> the <i>data directory</i> so of course, in the case, you'd
          have wanted to edit the <i>configuration file</i> in the new location).
        </li>
        <li>the step in the instructions under the header <i>systemcd configuration</i> was
          entirely skipped as explained in the introcution</li>
        <li>
          I then restarted the PostgreSQL cluster (database server) using:
          <pre>
systemctl daemon-reload
systemctl start postgresql.service
systemctl status postgresql.service</pre>
          <span class='nb'>NB:</span> the first command (<tt>systemctl daemon-reload</tt>) needs to be executed
          every time the <i>configuration file</i> changes so it's essential (merely stopping and restarting
          the cluster won't cut it).
        </li>
        <li>the step in the instructions under the header <i>SELinux</i> was also skipped
          as explained in the introduction</li>
        <li>to confirm that everything was ok I entirely <u>removed</u> the old data directory and
          connected to PostgreSQL to verify that the new locations are now recognized:<br/>
          <img src='./postgresql.html.files/change-postgresql-data-directory-step-9.png'/>
        </li>
      </ol>
    </p>
    <li id='configure-local-postgresql-to-allow-users-to-connect-over-dbeaver'>May 2024 &mdash; how I configured my local PostreSQL 12 to allow users to connect over DBeaver</li>
    <p>
      I tried to connect over DBeaver with an existing user and password and got:
<pre>
FATAL: no pg_hba.conf entry for host "127.0.0.1", user "mperdikeas", database "test", SSL on
</pre>
    </p>
    <p>
      After investigation and reading <a href='https://dba.stackexchange.com/a/122317/34332'>this SO answer</a>
      I got it to work after adding the following line on my <tt>/etc/postgresql/12/main/pg_hba.conf</tt>
      file:
      <pre>
host all           mperdikeas           127.0.0.1/32    md5</pre>
    </p>
    <p>
      <span class='nb'>NB:</span> It is important to use the <tt>/32</tt> notation. Simply writing
      <tt>127.0.0.1</tt> fails with the hardly elucidating message: <i>Connection refused (Connection refused)</i>
    </p>
    <p>
      No changes were necessary in the sibling file <tt>/etc/postgresql/12/main/postgresql.conf</tt>
      IIRC
    </p>
    <p>
      Following the above one, obviously, has to restart PostgreSQL:
      <pre>service postgresql restart</pre>
    </p>
    <li>how I created tablespaces in PostgreSQL</li>
<p>
I created a number of directories using:
<pre>
mkdir ~/postgresql-tblspaces && cd ~/postgresql-tblspaces
mkdir userspay2019 && chown -R postgres:postgres *
</pre>
&hellip; while at the same time creating the tablespaces
from inside <tt>psql</tt>:
<pre>
psql -U postgres
CREATE TABLESPACE userspay2019 LOCATION '/home/mperdikeas/postgresql-tblspaces/userspay2019';
</pre>
</p>
    <li>how to discover data directory and configration file in PostgreSQL</li>
<pre>
postgres=# show data_directory;
       data_directory        
-----------------------------
 /var/lib/postgresql/12/main
(1 row)</pre>
<br/>
<pre>postgres=# show config_file;
               config_file               
-----------------------------------------
 /etc/postgresql/12/main/postgresql.conf
(1 row)</pre>
    <li>streamlined procedure for setting up PostgreSQL 12 (December 2021)</li>
    <ol>
      <li class='step'>purge previous version</b></li>
<pre>
$ sudo apt remove --purge postgresql
$ sudo apt remove --purge postgresql-12*
</pre>
      <li class='step'>install PostgreSQL</li>
      Optionally with the PostGIS extension:
<pre>
$ sudo apt install postgis postgresql-12-postgis-3
$ sudo apt install postgresql-12
</pre>
<li class='step'>change password for PostgreSQL user <tt>postgres</tt></li>
<p>
    At this point you want to take advantage of the initial, default <i>peer</i>
  authentication mode to change the PostgreSQL password for the PostgreSQL user <i>postgres</i>.
  This will come into play later when you change the authentication mode
  for the <i>postgres</i> user (and any other user for that matter) from <i>peer</i>
  to <i>md5</i>:
<pre>
$ sudo -i -u postgres psql postgres
psql (12.9 (Ubuntu 12.9-2.pgdg20.04+1))
Type "help" for help.
+
postgres=# \password postgres
Enter new password: 
Enter it again: 
</pre>
</p>
<p id='better-way-to-check-for-locked-status-of-account'>
  Note that (according to my understanding) the above only affects the <i>PostgreSQL</i>
  user <tt>postgres</tt>, not the Unix user <tt>postgres</tt>. The latter in fact
  exists as can be verified by:
<pre>
$ cat /etc/passwd | grep -i postgres | wc -l
1
</pre>  
&hellip; but the account is "locked" (and you want to keep it locked as advised <a href='https://serverfault.com/questions/110154/whats-the-default-superuser-username-password-for-postgres-after-a-new-install/325596#325596'>in this SO answer</a>. The locked status can be verified by (<a href='https://www.2daygeek.com/lock-unlock-disable-enable-user-account-linux/'>source</a>):
<pre>
$ sudo passwd --status postgres
postgres L 05/26/2021 0 99999 7 -1
</pre>
</p>
<p>
  In general, you don't want to do anything with the UNIX user <tt>postgres</tt> and you
  <b>DEFINITELY</b> don't want to set a password for that user (as that would unlock the account) by doing a:<br/>
  <br/>
  <span class='nb'>DANGER: do not do the below:</span>
  <pre>$ sudo passwd postgres</pre>
  You can read more <a href='https://serverfault.com/a/325596'>in this SO answer</a>.
</p>
<li class='step'>create user and database</li>
<p>
  In the same vein you might also want to create an actual user (not <i>postgres</i>)
  while the <i>peer</i> authentication mode is still applicable:
<pre>
$ sudo -i -u postgres createuser --interactive johndoe
$ sudo -i -u postgres psql
psql (12.9 (Ubuntu 12.9-2.pgdg20.04+1))
Type "help" for help.

postgres=# ALTER USER johndoe WITH PASSWORD 'super.secret';
ALTER ROLE
</pre>
<pre>
$ sudo -u postgres psql -c 'create database acmeindustries';
CREATE DATABASE
</pre>
</p>


<li class='step'>make copies of the basic configuration files</li>
<pre>
$ cp /etc/postgresql/12/main/pg_hba.conf /etc/postgresql/12/main/pg_hba.conf.ORIGINAL
$ cp /etc/postgresql/12/main/postgresql.conf  /etc/postgresql/12/main/postgresql.conf.ORIGINAL
</pre>
<li class='step'>change authentication mode from <tt>peer</tt> to <tt>md5</tt></li>
<p>
In file <tt>pg_hba.conf</tt> change the following line:
<pre>local   all             postgres                                peer</pre>
to:
<pre>local   all             postgres                                md5</pre>
</p>
<p>
 In the same file, I have also done the following changes but I don't know how essential they are:</br>
  Change the following line:
<pre>
host    all             all             127.0.0.1/32            md5
</pre>
to:
<pre>
host    all             all             192.168.2.0/8           md5
</pre>
&hellip; and also comment out the replication lines at the end of the file (since I don't believe I am using this feature)
</p>
<li class='step'>create file <tt>~/.pgpass</tt></li>
<p>Now is a good time to create file <tt>~/.pgpass</tt> to make
  connecting to the database easier. Typical contents:
<pre>
$ cat ~/.pgpass
localhost:5432:postgres:postgres:super.secret
localhost:5432:acmeindustries:johndoe:duper.secret
</pre>
</p>
<p>
  You might also want to create the <tt>~/.psqlrc</tt> file but this is less
  useful (and might even be confusing at times if you are not aware of its existence):
<pre>$ cat ~/.psqlrc 
\set ON_ERROR_STOP on
</pre>
</p>
<li class='step'>configure PostgreSQL to listen to remote connections</li>
<p>
  To do that you have to edit the <tt>postgresql.conf</tt> file and
  change the <tt>listen_addresses</tt> setting. Typical value to instruct your
  machine (assuming your IP is <tt>192.168.2.2</tt>) to listen to the external <a href='https://en.wikipedia.org/wiki/Network_interface_controller'>NIC</a>
  and not just to the local loopback:
  <pre>listen_addresses = 'localhost, 192.168.2.2'</pre>
</p>

  <li class='step'>other configurations in <tt>postgresql.conf</tt></li>
<p>
      At this point, you might also want to change the <tt>port</tt> setting to a value other than the
  default of <tt>5432</tt>. This might be necessary if another PostgreSQL cluster (e.g.
  some previous version, say PostgreSQL 9) is also running on the same machine.
</p>
<p>
I also have found it necessary at times, e.g. when using migration tools to increase the value of <tt>max_locks_per_transaction</tt> to 1024.
  </p>
    </ol>
    <li>how to create user and database in PostgreSQL</li>
    <p>
      Tried that on PostgreSQL 12.9:<br/>
    <a href='https://stackoverflow.com/a/30642050/274677'>so answer</a>
    <li>how to take a dump of a PostgreSQL database</li>
    <p>
      Text dump:
      <pre>
pg_dump -U mperdikeas -h 192.168.2.9 -p 5432 -Fp dbname > /path/to/dump.txt</pre>
    </p>
    <p>
      Binary dump:
      <pre>
pg_dump -U mperdikeas -h 192.168.2.9 -p 5432 -Fc dbname > /path/to/dump.bin</pre>
    </p>
    <li>how to restore a PostgreSQL dump</li>
    <p>
    <span class='nb'>NB:</span> the database <i>dbname</i> needs to exist
    before running the command given below:
    <pre>
pg_restore -d dbname -U mperdikeas -h localhost /path/to/file.dump </pre>
    </p>
    <li>useful commands at <i>psql</i></li>
    <p>
      <dl>
        <dt>find current database</dt><dd><pre>SELECT current_database();</pre></dd>
        <dt>describe table</dt><dd><pre>\d+ tablename</pre></dd>
        <dt>list tables and databases, change databases etc</dt><dd>See <a href='https://dba.stackexchange.com/a/1288/34332'>this</a></dd>
      </dl>
    </p>
    <li>installation of <i>PostGIS</i> in PostgreSQL 12 (October 2021)</li>
    <p>I followed the instructions from <a href='https://computingforgeeks.com/how-to-install-postgis-on-ubuntu-debian/'>here</a>
    <pre>
sudo apt update
sudo apt install postgis postgresql-12-postgis-3</pre>
    </p>
    <p>
      &hellip; subsequently, I connected to the database I wanted to create
      the extension in with, e.g.:
      <pre>psql -U mperdikeas -d acme_industries</pre>
    </p>
    <p>
      &hellip; and then created the extension there with:
      <pre>CREATE EXTENSION postgis;</pre>
    </p>
    <p>
      So, apparently, the <i>PostGIS</i> extension is not installed on the PostgreSQL
      cluster as a whole, but on each particular database. This means that the
      extension has to be re-created whenever the database is dropped. Finally,
      I verified that the extension is now available with:
      <pre>SELECT PostGIS_version();</pre>
    </p>
    <li>installation and initial configuration of PostgreSQL 12 on Ubuntu 20.04 (May 2021)</li>
    <p>
      I followed the instructions from <a href='http://www.postgresql.org/download/linux/ubuntu/'>here</a> and asked, specifically, for <i>PostgreSQL 12</i> to be installed on the last step:

      <pre>
sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
sudo apt-get update
sudo apt-get -y install postgresql-12
</pre>
    </p>
    <p>
      I then verified that PostgreSQL was running by doing a:
      <pre>/etc/init.d/postgresql status</pre>
    </p>
    <p>
      Since the above does not report the version of PostgreSQL, I confirmed that it is PostgreSQL 12 that is running by doing a:
      <pre>pgrep -u postgres -fa -- -D</pre>
    </p>
    <p>
      Subsequently, to connect to PostgreSQL, I had to edit the file <tt>/etc/postgresql/12/main/pg_hba.conf</tt>. This controls the client authentication mechanisms and allows client-side tools
      (which use Unix Domain sockets) to connect to the database server.
      To that end, I was guided, more or less by <a href='#postgres-9-config'>this previous note</a></p>
    <p>
      Namely, since I had forgotten, or wasn't able to use, the default PostgreSQL password I
      initially changed the <i>local</i> authentication mode to 'trust'. I.e. I changed the line:
      <pre>local   all             postgres                                peer</pre>
      to:
      <pre>local   all             all                                     trust</pre>
      or (I am not really sure, but I dont think it makes much difference) to:
      <pre>local   all             postgres                                trust</pre>
      <span class='nb'>NB:</span> after each modification of the <tt>pg_hba.conf</tt> or <tt>postgresql.conf</tt> files you have to do a:
      <pre>/etc/init.d/postgresql restart</pre>
      &hellip; for the changes to take effect.
      This allowed me to change the <i>postgres</i> user password to:
      <pre>ALTER USER postgres PASSWORD 'supersecret';</pre>
      (mind the <tt>;</tt> at the end &mdash; it is important)
      Following that, I changed the authentication method for both <tt>local</tt> (i.e. Unix Domain sockets) and <tt>host</tt> (i.e. TCP/IP sockets) to <tt>md5</tt>:
      <pre>
local   all             all                                    md5
host    all             all   192.168.2.0/8                    md5</pre>

      The <tt>192.168.2.0/8</tt> means that the server is accepting connections from all IPv4 address in
      the local <tt>192.168.2.0/8</tt> subnet. There are much more permissive wildcards one can use,
      including any IP address on the Internet.
    </p>
    <p>
      However, following the above, I was still unable to connect to PostgreSQL from
      another machine (even though I had set <i>host</i> authentication to <tt>md5</tt>.
      Moreover, when trying
      to connect from other machines I was getting <i>connection refused</i> (or something).
    </p>
    <p>
      To fix that I had to instruct PostgreSQL to listen on the network card interface as well
      and not just on the localhost loop (which is the initial configuration for obvious
      security reasons). To do that I edited file <tt>/etc/postgresql/12/main/postgresql.conf</tt>
      and change the line
      <pre>#listen_addresses = 'localhost'</pre>
      to:
      <pre>listen_addresses = 'localhost, 192.168.2.7'</pre>
      After that I was able to connect remotely as well.
    </p>
    <p>
      <b>initial files:</b>
      <a href='./postgresql.html.files/postgres-12/pg_hba.conf.INITIAL'>pg_hba.conf</a>
      <a href='./postgresql.html.files/postgres-12/postgresql.conf.INITIAL'>postgresql.conf</a>
      <br/>
      <b>modified files:</b>
      <a href='./postgresql.html.files/postgres-12/pg_hba.conf'>pg_hba.conf</a>
      <a href='./postgresql.html.files/postgres-12/postgresql.conf'>postgresql.conf</a>      
    </p>
    <li><a name='postgres-9-config'></a>how I setup the postgres user in PostgreSQL 9.5 and created user 'mperdikeas'</li>
    <p>
      PostgreSQL allows one to authenticate using two mechanisms:
      <ul>
        <li>the so called <i>IDENT/PEER</i> authentication which uses UNIX accounts</li>
        <li>the <i>TCP</i> authentication which uses PostgreSQL's own managed username / passwords</li>
      </ul>
      You want to keep the <tt>postgres</tt> UNIX account locked (for security purposes). So I did the following:
      <pre>
sudo passwd --lock postgres</pre>
      &hellip; and subsequently verified that the <tt>postgres</tt> UNIX account is indeed locked by doing:
      <pre>
$ sudo cat /etc/shadow | grep -i postgres
postgres:!*:17117:0:99999:7:::
$ sudo passwd -S postgres
postgres L 11/12/2016 0 99999 7 -1</pre>
    You may read more <a href='https://serverfault.com/a/325596/139074'>here</a>.
    </p>
    <p><span class='nb'>update 2021-12-15</span> An easier way to check
      for the locked status of an account is offered <a href='#better-way-to-check-for-locked-status-of-account'>here</a>.
      </p>
    <p>
      I then changed the password of the TCP user <tt>postgres</tt> by doing:
      <pre>$ sudo -i -u postgres psql postgres
psql (9.5.19)
Type "help" for help.

postgres=# \password postgres
Enter new password:
Enter it again:</pre>
    </p>
    <p>
      Finally, I created a new TCP user <tt>mperdikeas</tt> and set his password:
      <pre>
$ sudo -i -u postgres createuser --interactive mperdikeas
Shall the new role be a superuser? (y/n) n
Shall the new role be allowed to create databases? (y/n) y
Shall the new role be allowed to create more new roles? (y/n) n
$ sudo -i -u postgres psql
psql (9.5.19)
Type "help" for help.

postgres=# ALTER USER mperdikeas WITH PASSWORD '&lt;redacted&gt;';
ALTER ROLE
postgres=# \q</pre>
    </p>
    <p>
      You will notice that for all administrative commands we are using the UNIX user <tt>postgres</tt>
    </p>
    <p>
      <span class='nb'>NB:</span> be sure to set the authentication method to 'md5' in the following file:
      <pre>/etc/postgresql/9.5/main/pg_hba.conf</pre>
      (allowed values are <i>trust</i>, <i>peer</i> and <i>md5</i>)
    </p>
    <li><a href='http://serverfault.com/a/325596/139074'>why you shouldn't change the password of the <tt>postgres</tt> Linux user using <tt>sudo passwd postgres</tt></a>
    <li><a href='postgresql.html.files/install-postgresql9.5-in-Ubuntu-14.04-trusty-thar.html'>Install Postgresql 9.5 in Ubuntu 14.04 Trusty Tahr</a></li>
    <li><a href='postgresql.html.files/timstamp-with-or-without-timezone.html'>timestamps with or without timezones</a></li>
    <li>how to write recursive SQL WITH queries</li>
    <p>Today I implemented the following SSCCE to dig recursive WITH queries:</p>
    <p>Let's first define a simple schema to represent trees so we can motivate
      a use case of recursive queries.<br/>
      We can imagine having two tables to represent two kinds of nodes:
      <ul>
        <li>"proper" nodes</li>
        <li>leaf nodes, which can hang under any "proper" node (including internal ones)</li>
      </ul>
    </p>
    <p>
      A possible approach would be the following:
      <pre>
    DROP TABLE IF EXISTS leaf;
    DROP TABLE IF EXISTS node;

    CREATE TABLE node (
        i         INTEGER NOT NULL,
        parent    INTEGER     NULL
    );
    ALTER TABLE node ADD PRIMARY KEY(i);

    CREATE TABLE leaf (
        i         SERIAL,
        leafName  VARCHAR NOT NULL,
        underNode INTEGER NOT NULL);
    ALTER TABLE leaf ADD PRIMARY KEY (i);
    ALTER TABLE leaf ADD FOREIGN KEY (underNode) REFERENCES node(i);
      </pre>
    </p>
    <p>One can imagine the above schema to be populated with the below test data:
      <pre>
    INSERT INTO node VALUES
    (1, NULL), (2, NULL), (3, 1), (5, 1), (7, 1), (4, 2), (6, 2);

    INSERT INTO leaf(leafName, underNode) VALUES
    ('leaf under 1', 1), ('leaf under 2', 2), ('leaf under 3', 3), ('leaf under 5', 5), ('leaf under 7', 7);
      </pre>
    </p>
    <p>Given the above, the following query fetches the names of all leaves hanging under the 'subtree'
      of node with key #1:
      <pre>
    WITH RECURSIVE NODES_IN_SUBTREE (i) AS (
        VALUES (1)
        UNION ALL SELECT a.i FROM NODES_IN_SUBTREE INNER JOIN node a
        ON a.parent = NODES_IN_SUBTREE.i
    )
    SELECT leafName FROM leaf
    WHERE underNode IN (SELECT i FROM NODES_IN_SUBTREE);
      </pre>
    </p>
    <p>
      &hellip; and the following query fetches all leaves that live under the 'subtrees' of all nodes who are children
      of the root of the tree (therefore, effectively fetches <b>all</b> leaves in the tree):
      <pre>
    WITH RECURSIVE NODES_IN_SUBTREE (i) AS (
        (SELECT i FROM node WHERE parent IS NULL)
        UNION ALL SELECT a.i FROM NODES_IN_SUBTREE INNER JOIN node a
        ON a.parent = NODES_IN_SUBTREE.i
    )
    SELECT leafName FROM leaf
    WHERE underNode IN (SELECT i FROM NODES_IN_SUBTREE);
      </pre>
    </p>
    <li>how to create superuser "<b>postgres</b>" if none exists when the PostgreSQL is built from sources</li>
    <a href='#typical-access-control-configurations'>relevant note</a>
    <br/>
    On 2016-04-20 I faced the following situation: a colleague built and configured a PostgreSQL 9.4 cluster
    on my home directory and apparently no superuser 'postgres' was created. The steps the colleague executed
    were the bold ones from the following:
    <ol>
      <li><b>      ./configure</b></li>
      <li><b>      make</b></li>
      <li><b>      su</b></li>
      <li><b>      make install</b></li>
      <li>      adduser postgres</li>
      <li><b>      mkdir /usr/local/pgsql/data</b></li>
      <li>      chown postgres /usr/local/pgsql/data</li>
      <li>      su - postgres</li>
      <li><b>      /usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</b></li>
      <li>      /usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data >logfile 2>&1 &</li>
      <li>      /usr/local/pgsql/bin/createdb test</li>
      <li>      /usr/local/pgsql/bin/psql test</li>
    </ol>
    <br/>
    Except for the fact that the path was not <tt>/usr/local/pgsql</tt>, but rather <tt>~/postgresql-9.4.5</tt>.
    <br/>
    <br/>Also, the command at item #10 is just to start the database cluster server. Instead I could start the server
    myself with the following:
    <pre>./postgres-9.4.5/bin/postgres -D ./postgres-9.4.5/data/</pre>

    The main problem that there was no superuser which I could use to connect to the PostgreSQL cluster (using <tt>psql</tt>)
    and from there on to create my own project-specific database and user.
    <br/><br/>
    To that end, I created a user <tt>postgres</tt> as follows:
    <pre>createuser --interactive postgres</pre>

    <br/>... and proceed to answer "yes" to the question whether the user ought to be a superuser.
    <br/>
    <br/>
    <div id='edit-of-pg_hba.conf-9.4.5'>
    I then changed <tt>~/postgres-9.4.5/data/pg_hba.conf</tt>
      to contain:
      <pre>
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            md5
# IPv6 local connections:
host    all             all             ::1/128                 md5

</pre></div>
<br/>... and then connected as user <tt>postgres</tt> and changed its password to:
<pre>
$ which psql
~/postgres9/bin/psql
rawdar@radacerd:~#
$ psql -U postgres
psql (9.4.5)
Type "help" for help.

postgres=# alter user postgres password 'secret';
</pre>
<br/>... even though that was not strictly necessary as I was only connecting as user <tt>postgres</tt>
using <tt>psql</tt> which uses Unix domain sockets and thus falls under the <tt>trust</tt> model.
<br/><br/>
Following the above I was able to run my subsequent (domain-specific) scripts that created the project
user and its database (and which rely on <tt>psql</tt> access with the superuser <tt>postgres</tt>).
<br/><br/>
What I understood from the above is that when PostgreSQL 9.4 is created in the home directory of an arbitrary
user there's nothing special about the <tt>postgres</tt> user, any superuser who can create additional roles
and databases will do.
<br/>
<br/>
Note in the above connection that <tt>postgres</tt> is a user of the PostgreSQL cluster
(or, more correctly, a <tt>role</tt>) and not a Unix/Linux system user.
    <li>how to configure retention of unresponsive TCP connections in PostgreSQL</li>
    I've used the following settings:
    <pre>
#tcp_keepalives_idle = 0                # TCP_KEEPIDLE, in seconds;
                                        # 0 selects the system default
tcp_keepalives_idle = 200               # TCP_KEEPIDLE, in seconds;
#tcp_keepalives_interval = 0            # TCP_KEEPINTVL, in seconds;
                                        # 0 selects the system default
tcp_keepalives_interval = 30            # TCP_KEEPINTVL, in seconds;
#tcp_keepalives_count = 0               # TCP_KEEPCNT;
                                        # 0 selects the system default
tcp_keepalives_count = 10               # TCP_KEEPCNT;

    </pre>
    ...in this file: <tt>/postgresDB/data-9.1.14/postgresql.conf</tt> at
    the new EuroVO registry PostgreSQL cluster.
    <br/>
    Sources:
    <br/>
<a href='http://stackoverflow.com/a/2186617/274677'>SO</a>, <a href='http://www.gnugk.org/keepalive.html'>GNU Gatekeeper keepalive page</a>
    <li>how to kill non-responsive PostgreSQL queries</li>
    <pre>
    select pg_terminate_backend(procpid)
    from pg_stat_activity
    where usename = 'yourusername'
     and current_query = '&lt;IDLE&gt;'
     and query_start < current_timestamp - interval '5 minutes'
     ;
    </pre>
    <a href='http://serverfault.com/a/577722/139074'>source</a>
    <li>how to query PostgreSQL for currently executing queries</li>
    <ul>
      <li>Using the <tt>pg_stat_activity</tt> table</li>
      This method requires no installation (but I've never managed to extract much useful information from it):
      <pre>SELECT * FROM pg_stat_activity</pre>
      <li>Using the <tt>pg_stat_statements</tt> table</li>
      This method requires the installation of some additional libraries as described <a href="http://dba.stackexchange.com/q/124054/34332">in this dba.stackexchange post</a> but offers more useful information:
      <pre>SELECT * FROM pg_stat_statements ORDER BY total_time DESC </pre>
    </ul>
    <li>sample configuration files used</li>
    <dl>
      <dt><strong>postgresql.conf</strong></dt>
      <dd>
        <ol>
          <li>PostgreSQL 9.3 in Ubuntu 14.04 (NP desktop)</dt></li>
          Residing in: <a href="postgres9_3-NP-desktop-postgresql.conf">/etc/postgresql/9.3/main/postgresql.conf</a>
          <br/>
          <strong>NB:</strong> not to be confused with the <tt>postgresql.conf.sample</tt> file
          residing in:
          <br/>
          <tt>/usr/share/postgresql</tt>
          <br/>
          ... of which I had made a copy named <tt>postgresql.conf</tt> that led to the confusion reported in
          <a href="http://dba.stackexchange.com/q/124852/34332">this StackOverflow post</a>.
        </ol>
      </dd>
      <dt><strong>pg_hba.conf</strong></dt>
      <dd>
        <ol>
          <li>PostgreSQL 9.3 in Ubuntu 14.04 (NP desktop)</dt></li>
          Residing in: <a href="postgres9_3-NP-desktop-pg_hba.conf">/etc/postgresql/9.3/main/pg_hba.conf</a>
        </ol>
      </dd>      
    </dl>
    <li>awesome PostgreSQL CLI client with auto-completion and syntax highlighting</li>
    Source: <a href="https://github.com/dbcli/pgcli">https://github.com/dbcli/pgcli</a>
    <pre>
sudo apt-get install python-pip
sudo apt-get install python-dev libpq-dev libevent-dev
sudo pip install pgcli
    </pre>
    <li>how to convert VARCHAR data to XML so that the XPATH function may be used on them</li>
Use the <tt>XMLPARSE</tt> function:
    <pre>
SELECT DISTINCT CAST (XPATH('@status',XMLPARSE(CONTENT "content")) AS VARCHAR), isdeleted
FROM vo_business.hosted_record_version
    </pre>
    <li>During PostgreSQL startup: <tt>could not open file "/etc/ssl/private/ssl-cert-snakeoil.key": Permission denied</tt></li>
    Encountered this problem for PostgreSQL 9.1 on Ubuntu 12.04.<br/>
    The following solution worked for me:
    <pre>
sudo chown postgres /etc/ssl/private/ssl-cert-snakeoil.key
sudo chown postgres /etc/ssl/certs/ssl-cert-snakeoil.pem
    </pre>
    <li>Install PostgreSQL From Its Official Repository in Ubuntu 14.04</li>
    The PostgreSQL Global Development Group (PGDG) maintains an APT repository of PostgreSQL packages for Debian and Ubuntu. The repository provides the PostgreSQL server packages as well as extensions and modules packages for all PostgreSQL versions supported.
    <br/>
    So far, the repository support:
    <ul>
      <li>Debian 6.0 (squeeze), 7.0 (wheezy), and unstable (sid) 64/32 bit (amd64/i386)</li>
      <li>Ubuntu 10.04 (lucid), 12.04 (precise), and 14.04 (trusty) 64/32 bit (amd64/i386)</li>
      <li>PostgreSQL 8.4, 9.0, 9.1, 9.2, 9.3</li>
      <li>Server extensions such as Slony-I, various PL languages, and datatypes</li>
      <li>Applications like pgadmin3, pgbouncer, and pgpool-II</li>
    </ul>
    To get started installing PostgreSQL on Ubuntu 14.04, do the following steps:
    <ol>
      <li>Create and edit the PostgreSQL repository by running the command below:</li>
      <pre>
sudo emacs -nw /etc/apt/sources.list.d/pgdg.list
      </pre>
      Insert the following line:
      <pre>
deb http://apt.postgresql.org/pub/repos/apt/ trusty-pgdg main
      </pre>
      <li>Download & import the repository key:</li>
      <pre>
wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
      </pre>
      <li>Update your system:</li>
      <pre>
sudo apt-get update && sudo apt-get upgrade
      </pre>
      <li>Now you're able to install PostgreSQL via below command:</li>
      <pre>
sudo apt-get install postgresql-9.3 pgadmin3
      </pre>
    </ol>
    <b>NB:</b> This repository provides <tt>postgresql</tt>, <tt>postgresql-contrib</tt>, and <tt>postgresql-client</tt> meta-packages that depend on the latest <i>postgresql-x.y</i> packages, similar to the ones present in Debian and Ubuntu. Once a new PostgreSQL version is released, these meta-packages will be updated to depend on the new version. If you rather want to stay with a particular PostgreSQL version, you should install specific packages like <tt>postgresql-9.3</tt> instead of <tt>postgresql</tt>.
    <br/>
    <a href="http://ubuntuhandbook.org/index.php/2014/02/install-postgresql-ubuntu-14-04/">source</a>
    <li>how to execute PL/pgSQL blocks, function definitions, transactions in DbVisualizer</li>
    Instead of the <i>Execute</i> or <i>Execute Current</i> options, use the <i>Execute Buffer</i>
    as shown in the screenshot below:
    <br/>
    <a href="dbvis-execute-buffer.png">
      <img height="200px" width="300px" src="dbvis-execute-buffer.png"/>
    </a>.
    <li>examining (and terminating, if need be) user sessions</li>
    Sometimes you just need to kill a user session (e.g. that may be preventing your from droping and recreating your database).
    Restarting PostgreSQL is one option. A more fine-grained one is to kill the user sessions.
    <br/>
    Start by examining user sessions:
    <pre>SELECT * FROM pg_stat_activity;</pre>
    Cancel the backend process (gentle):
    <pre>SELECT pg_cancel_backend( <procpid> );</pre>
      &hellip; if the above doesn't work (it didn't in my case), try the more forceful:
      <pre>
SELECT pg_terminate_backend( <procpid> );
      </pre>
      <a href="http://www.devopsderek.com/blog/2012/11/13/list-and-disconnect-postgresql-db-sessions/">source</a>
      <li>configuration of logging directory in Postgresql (in Ubuntu 12.04)</li>
      This is where it's done:
      <pre>
sudo cat /etc/postgresql/9.1/main/postgresql.conf | grep log_directory
      </pre>
      <li>yet more complex XPath example</li>
      <pre>
SELECT
DISTINCT ivoid, CAST(xpath('//*[local-name()=''capability'' and @xsi:type=''ssa:SimpleSpectralAccess'']/*[local-name()=''testQuery'']' , content, ARRAY[ARRAY['xsi', 'http://www.w3.org/2001/XMLSchema-instance']]) AS VARCHAR)
FROM rr.resourcecontent
WHERE CAST(xpath('//*[local-name()=''capability'' and @xsi:type=''ssa:SimpleSpectralAccess'']/*[local-name()=''testQuery'']' , content, ARRAY[ARRAY['xsi', 'http://www.w3.org/2001/XMLSchema-instance']]) AS VARCHAR)!='{}'
      </pre>
      <li>complex XPath example demonstrating namespace-agnostic <i>local-name</i>, testing if a value belongs in a list, and need to CAST from XML to VARCHAR</li>
      <pre>
SELECT 
CAST(xpath('//*[local-name()=''capability'' and (@standardID=''ivo://ivoa.net/std/SIA'' or @standardID=''ivo://ivoa.net/std/SSA'')]/@standardID' , content) AS VARCHAR), count(*)
FROM someschema.sometable
GROUP BY CAST(xpath('//*[local-name()=''capability'' and (@standardID=''ivo://ivoa.net/std/SIA'' or @standardID=''ivo://ivoa.net/std/SSA'')]/@standardID' , content) AS VARCHAR)
      </pre>
      <li>downloading the results of a SQL query on local filesystem</li>
      <a href="http://stackoverflow.com/a/11870348/274677">source</a><br/>
      Example:<br/>
      <pre>
psql -d RegTAP -t -A -F"," -c "SELECT pregraft FROM vo_business.harvest_record WHERE recordivoid='ivo://irsa.ipac/Spitzer/Images/SINGS'" > pregraft
      </pre>
      <li>using XPath with namespaces in PostgreSQL</li>
      <a href="http://www.postgresql.org/docs/9.1/static/functions-xml.html">PostgreSQL 9.1 docs</a>
      <br/>
      Example (including also a cast):<br/>
      <pre>
SELECT ivoidlowercase, xpath('@xsi:type', content, ARRAY[ARRAY['xsi', 'http://www.w3.org/2001/XMLSchema-instance']])
FROM rr.resourcecontent 
WHERE lower(CAST (xpath('@xsi:type', content, ARRAY[ARRAY['xsi', 'http://www.w3.org/2001/XMLSchema-instance']]) AS VARCHAR)) LIKE '%vs:dataservice%'
      </pre>
      <li id='typical-access-control-configurations'>typical access control configurations</li>
      The rationale is the following:
      <ul>
        <li>trust all local UNIX-domain sockets (that tools like <b>psql</b> are using to create database and user
          in the various scripts)</li>
        <li>configure password-based authentication (md5) for TCP/IP sockets</li>
      </ul>
      <br/>
      E.g. (as found in my SAT machine)
      <pre>
$ sudo cat /etc/postgresql/9.1/main/pg_hba.conf  | grep -v ^# | uniq

local   all             postgres                                trust
local   all             all                                     trust
host    all             all             127.0.0.1/32            md5
host    all             all             ::1/128                 md5

      </pre>
      <li>Terminology on <i>clusters</i>, <i>catalogs</i>, <i>databases</i> and <i>schemas</i></li>
      <a href="http://stackoverflow.com/a/17943883/274677">source</a>
      <br/>
      A <b>cluster</b> in Postgres is simply a Postgres installation. Cluster here is not meant in the hardware sense of
      multiple computers working together. In Postgres, cluster refers to the fact that you can multiple unrelated databases all up and
      running using the same Postgres server engine. So, in other words, a <b>cluster</b> is a database server.
      <br/>
      So in both Postgres and the SQL Standard we have this containment hierarchy:
      <ul>
        <li>A computer may have one or multiple <b>clusters</b>.</li>
        <li>A database server is a cluster.</li>
        <li>A cluster has <b>catalogs</b>. ( Catalog = <b>Database</b> )</li>
        <li>Catalogs have <b>schemas</b>. (Schema = namespace of tables, and security boundary)</li>
        <li>Schemas have <b>tables</b>.</li>
        <li>Tables have <b>rows</b>.</li>
        <li>Rows have <b>values</b>, defined by columns.</li>
      </ul>
      The drawing below sums it up nicely:
      <br/>
      <img src="postgres-cluster-catalog-schemas.png">



      <li>online SQL playground / sandbox</li>
      <a href="http://sqlfiddle.com/">SQL fiddle</a>
      <li>Window functions (latest installment)</li>
      New insight into the logic of window functions:
      <ul>
        <li>The <b>PARTITION</b> clause defines the window, however some functions by default operate on a concept called the 'frame' which may by, default include less than the full window
          E.g. see what <a href="http://www.postgresql.org/docs/9.2/static/functions-window.html"> postgreSQL</a> says:
          <br/><i>
            Note that first_value, last_value, and nth_value consider only the rows within the "window frame", which by default contains the rows from the start of the partition through the last peer of the current row. This is likely to give unhelpful results for last_value and sometimes also nth_value. You can redefine the frame by adding a suitable frame specification (RANGE or ROWS) to the OVER clause. See Section 4.2.8 for more information about frame specifications.
          </i>
          <br/>
        </li>
        <li>In the same vein:
          <ul>
            <li><b>over (order by x)</b></li>
            is really shortcut for:
            <li><b>over (order by x rows between unbounded preceding and current row)</b></li>
            ... and so, sometimes (see example below), the below form is needed:
            <li><b>over (order by x rows between unbounded preceding and unbounded following</b></li>
          </ul>
        </li>
        <li>helpful site and other links:
          <ul>
            <li><a href="http://tapoueh.org/blog/2013/08/20-Window-Functions">3rd-party turotial on window functions</a></li>
            <li><a href="http://www.postgresql.org/docs/9.1/static/tutorial-window.html">PostgreSQL tutorial</a></li>
            <li><a href="http://www.postgresql.org/docs/9.2/static/functions-window.html">PostgreSQL window functions</a></li>
            <li><a href="http://www.postgresql.org/docs/9.2/static/functions-aggregate.html">PostgreSQL aggregate functions</a></li>
          </ul>
        </li>
      </ul>
      <br/>
      Some instructive examples follow:
      <br/>
      <pre>
-- order by x means "order by x rows between unbounded preceding and current row
select x, array_agg(x) over (rows between unbounded preceding and current row) from generate_series(1, 10) AS t(x)
select x, array_agg(x) over (order by x rows between unbounded preceding and current row) from generate_series(1, 10) AS t(x)
select x, array_agg(x) over (order by x) from generate_series(1, 10) AS t(x)

select foo.*, first_value(i) over (partition by a order by i desc) from foo

select foo.*, lag(i) over (partition by a order by i asc) from foo

select foo.*, lag(i, 2) over (partition by a order by i asc) from foo
select foo.*, lag(i, 2, -1) over (partition by a order by i asc) from foo

select x, array_agg(x) over (rows between current row and unbounded following) from generate_series(1, 10) AS t(x)
select x, array_agg(x) over () from generate_series(1, 10) AS t(x)
select x, array_agg(x) over (order by x) from generate_series(1, 10) AS t(x)

CREATE TABLE employee_salary(employee VARCHAR, department VARCHAR, salary INTEGER);
INSERT INTO employee_salary
VALUES
('mike', 'sales',  90000),
('john', 'sales', 130000),
('paul', 'sales',  70000),
('anna', 'dev'  ,  20000),
('peter','dev'  ,  50000)

SELECT employee, salary, department,
round(AVG(salary) OVER (PARTITION BY department),0) AS average_dept_salary,
rank() OVER (PARTITION BY department ORDER BY salary DESC) AS salary_rank,
lead(salary) OVER (PARTITION BY department ORDER BY salary ASC) AS next_higher,
lag (salary) OVER (PARTITION BY department ORDER BY salary ASC) AS prev_lower,
first_value(salary) OVER (PARTITION BY department ORDER BY salary ASC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS lowest_salary_in_department,
last_value (salary) OVER (PARTITION BY department ORDER BY salary ASC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS highest_salary_in_department
FROM employee_salary
      </pre>

      <li>how to install <b>pgsphere</b></li>
      I followed the instructions from <a href="http://pgsphere.projects.pgfoundry.org">the pgSphere 1.1 project site</a>
      with the following qualifications and log:
      <ol type="i">
        <li>downloaded pgSphere sources from <a href="http://pgfoundry.org/projects/pgsphere/">the pgSphere homepage</a></li>
        <pre>
    wget http://pgfoundry.org/frs/download.php/2558/pgsphere-1.1.1.tar.gz
        </pre>
        <li>I opted for the <i>second way</i> to compile <b>pgSphere</b> (as instructed in <a href="http://pgsphere.projects.pgfoundry.org/x44.html">the installation instructions page</a>), which is the one that does not require the PostgreSQL sources but, instead, the configuration tool <b>pg_config</b></li>
        <li>since <b>pg_config</b> didn't exist I installed it by executing:
          <pre>
sudo apt-cache search postgresql-server-dev
sudo apt-get install postgresql-server-dev-9.1
          </pre>
          Now, <b>pg_config</b> is installed and its location can be got with:<pre>which pg_config</pre> (we use that location below)
        </li>
        <li>expand the pgSphere tarball we downloaded and cd into the directory that's created:
          <pre>
tar xvfz pgsphere-1.1.1.tar.gz
cd pgsphere-1.1.1/
          </pre>
        </li>
        <li>follow the installation instructions linked above ("<i>second way</i>"), replacing "/path/to/pg_config" with the actual path</li>
        <pre>
make USE_PGXS=1 PG_CONFIG=/usr/bin/pg_config
sudo make USE_PGXS=1 PG_CONFIG=/usr/bin/pg_config install
        </pre>
        <li>when I tried to check the installation as instructed:
          <br/><br/><i>To check the installation change into the pg_sphere source directory again and run:
            <br/>
            shell> make installcheck
          </i><br/><br/>... I got the following error trace:
          <pre>
Makefile:29: ../../src/Makefile.global: No such file or directory
Makefile:30: /contrib/contrib-global.mk: No such file or directory
make: *** No rule to make target `/contrib/contrib-global.mk'.  Stop.
          </pre>
          ... but the installation was successful nonetheless because I was able to execute the last step as
          advised in "<i>2.3. Creating a database with pgSphere</i>" of the installation instructions linked above with:
          <pre>
psql -U postgres -d RegTAP -f ./pg_sphere.sql
          </pre>
      </ol>
      <li>Window functions (cont.)</li>
      Note that <b>PARTITION</b> is not the function to be used in the <b>OVER</b> clause, <b>ORDER</b> is also available.
      E.g. to produce a salary rank for each employee according to his salary (the rank of '1' being assigned to the
      highest salary), one can do a:
      <pre>
SELECT emp_name, salary, RANK() OVER (ORDER BY salary DESC) AS sal_pos 
FROM test_curation.employee
ORDER BY sal_pos ASC
      </pre>

      (contrast the results, with those one gets when using <b>ROW_NUMBER()</b> instead of <b>RANK</b>)

      This can allow us to obtain the three highest paid employees, where using the simpler <b>LIMIT</b>
      clause of PostgreSQL would fail because of the tie on the third rank (Elizabeth and Flora).
      The below simple approach shows only one of the two employees with a salary of 4:

      <pre>
SELECT emp_name, salary
FROM test_curation.employee
ORDER BY salary DESC
LIMIT 3
      </pre>

      ... whereas using the window function <b>RANK()</b> one is able to get both of them:

      <pre>
SELECT x.* FROM (
SELECT emp_name, salary, rank() OVER (ORDER BY salary DESC) AS sal_pos 
FROM test_curation.employee
ORDER BY sal_pos ASC) x
WHERE x.sal_pos<=3
      </pre>
      <br/>
      There is also the <b>DENSE_RANK()</b> function which continues counting, in case of ties, 
      from the exactly previous rank (whereas <b>RANK()</b> in case of ties leaves a gap as wide
      as the number of tied elements).

      <li>Window functions rock!</li>
      <pre>
DROP TABLE IF EXISTS test_curation.employee;
CREATE TABLE test_curation.employee (
department VARCHAR,
emp_name VARCHAR,
salary INTEGER);

INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('SALES', 'MIKE', 3);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('SALES', 'MARJORIE', 5);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('SALES', 'ELIZABETH', 4);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('SALES', 'FLORA', 4);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('DEV', 'THOMAS', 10);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('DEV', 'GEORGE', 2);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('DEV', 'MENELAUS', 1);

-- simple example to demonstrate the use of the window function AVG
SELECT department, emp_name, AVG(salary) OVER (PARTITION BY department), rank() OVER (PARTITION BY department ORDER BY salary DESC)
FROM test_curation.employee;

-- using the window function rank, observe that both Elizabeth and Flora appear as rank() assigns the same number
-- in case of ties
SELECT department, emp_name, salary, avg FROM
(SELECT department, emp_name, salary, AVG(salary) OVER (PARTITION BY department), rank() OVER (PARTITION BY department ORDER BY salary DESC)
FROM test_curation.employee) r
WHERE rank<=2;

-- rank() assigns the same number in case of ties() and also leaves gaps right after a tie:
SELECT department, emp_name, salary, avg FROM
(SELECT department, emp_name, salary, AVG(salary) OVER (PARTITION BY department), rank() OVER (PARTITION BY department ORDER BY salary DESC)
FROM test_curation.employee) r
WHERE rank=3;

-- row_number() always assigns different numbers and in case of a tie one row is chosen based on some arbitrary criterion (e.g. actual order fetched maybe?)
SELECT department, emp_name, salary, avg FROM
(SELECT department, emp_name, salary, AVG(salary) OVER (PARTITION BY department), row_number() OVER (PARTITION BY department ORDER BY salary DESC)
FROM test_curation.employee) r
WHERE row_number<=2;
      </pre>
      <li>PostgreSQL-specific way to get maximum or minimum values of certain columns for every combination of other columns</li>
      This is using the PostgreSQL-specific <b>DISTINCT ON</b> syntax (an extension on the SQL standard <b>DISTINCT</b> for specific
      columns).
      <br>
      Given the below table:
      <pre>
CREATE TABLE A (A1 INTEGER, A2 INTEGER, A3 INTEGER);

INSERT INTO A(A1, A2, A3) VALUES (1, 1, 1);
INSERT INTO A(A1, A2, A3) VALUES (2, 1, 1);
INSERT INTO A(A1, A2, A3) VALUES (2, 1, 2);
INSERT INTO A(A1, A2, A3) VALUES (3, 1, 2);
INSERT INTO A(A1, A2, A3) VALUES (2, 1, 2);
INSERT INTO A(A1, A2, A3) VALUES (4, 1, 2);
INSERT INTO A(A1, A2, A3) VALUES (4, 1, 5);
INSERT INTO A(A1, A2, A3) VALUES (3, 1, 5);
      </pre>
      The following obtains minimum <b>a1</b> values for every combination of <b>a2</b> and <b>a3</b>:
      <pre>
SELECT DISTINCT ON (a2, a3) a2, a3, a1 FROM A ORDER BY a2, a3, a1
      </pre>
      <br>Whereas the following does the same, for maximum <b>a1</b> values:
      <pre>
SELECT DISTINCT ON (a2, a3) a2, a3, a1 FROM A ORDER BY a2, a3, a1 DESC
      </pre>

      <li>how to drop a database in PostgreSQL</li>
      Three ways:
      <ol type="i">
        <li>command line only:</li>
        <pre>dropdb &ltdatabase name&gt</pre>
        <li>more refined, once connected as <i>postgres</i> superuser:</li>
        <pre>DROP DATABASE IF EXISTS &ltdatabase name&gt</pre>
        <li>the way above from the command line:</li>
        <pre>psql -U postgres postgres -f &ltfile with the above script&gt</pre>
      </ol>
      <li>how to handle namespace prefixes in <b>xpath</b> queries</li>
      Simple case (1 namespace prefix):
      <pre>
SELECT ( CAST (xpath('/*/@xsi:type', content, array[array['xsi', 'http://www.w3.org/2001/XMLSchema-instance']]) AS TEXT[]))[1] from rr.resourcecontent
      </pre>
      <br/>More complicated case (2 namespace prefixes):
      <pre>
SELECT ( CAST (xpath('/ri:Resource/@xsi:type', content, array[array['xsi', 'http://www.w3.org/2001/XMLSchema-instance'],
                                                              array['ri', 'http://www.ivoa.net/xml/RegistryInterface/v1.0']]) AS TEXT[]))[1] from rr.resourcecontent
      </pre>
      <li>another very useful syntax for doing <b>xpath</b> in PostgreSQL</li>
      Basic idea is that we cast the xpath result to a text array and we take the first element (that's
      when we know that the xpath expression will return a single value only):
      <pre>
SELECT ( CAST (xpath('/*/identifier', content) AS TEXT[]))[1] from rr.resourcecontent
      </pre>
      <li>how to check if a value appears in an array</li>
      The expression below evals to <b>true</b>
      <pre>
select 'a' = ANY ('{a , b}'::varchar[])
      </pre>
      <li>how to use <b>xpath</b> in where clauses in PostgreSQL</li>
      <b>xpath</b> types cannot be directly compared to string literals, so one has to do a cast, e.g.:
      <pre>
select count(*) from rr.resourcecontent where cast (xpath('/*/capability/@standardID', content) as text[])='{ivo://ivoa.net/std/ConeSearch}'
      </pre>
      - or - <i>(to allow use of PostgreSQL <b>trim</b> function - but only if only one item is returned)</i>:
      <pre>
select count(*) from rr.resourcecontent where trim( cast (xpath('/*/capability/@standardID', content) as text))='{ivo://ivoa.net/std/ConeSearch}'
      </pre>
      - or - <i>(if an array of values may be returned by the XPath expression)</i>:
      <pre>
select count(*) from rr.resourcecontent where 'ivo://ivoa.net/std/ConeSearch' = ANY (cast (xpath('/*/capability/@standardID', content) as text[]) )
      </pre>
      (I haven't found a way how to cast to a text array <b>and</b> do a <b>trim()</b> at the same time).
      <li>various types of inserts in PostgreSQL</li>
      A good report comparing:
      <ol type=a>
        <li>VSI - very silly inserts (executing queries made by concatenated Strings, one-by-one)</li>
        <li>SPI - stupid prepared inserts (executing queries made by Prepared Inserts one-by-one)</li>
        <li>BPI - batch prepared inserts (executing queries made by Prepared Inserts in batches)</li>
        <li>CPI - copy inserts (using the 'properietary' COPY FROM API offered by PostgreSQL driver)</li>
      </ol>
      </p> ... is given <a href="http://rostislav-matl.blogspot.com.es/2011/08/fast-inserts-to-postgresql-with-jdbc.html">here</a>.
      Results graph is:</p><img src="inserts-linechart.png">
      </p>My take is that BPIs are good enough without having to venture out onto non-standard CPI-land.
      <br>Caveat: according to <a href="http://stackoverflow.com/questions/12012592/jdbc-insert-multiple-rows">this SO discussion</a>
      auto commit should be set to false for 
      BPI to offer any advantage over SPI (setting auto commit to false is one JDBC's best practices anyway).

      <li>location of <b>pg_ctl</b> in Postgresql 9.2</li>
      <pre>/usr/lib/postgresql/9.2/bin/pg_ctl</pre>
      <li>NULL values in foreign key columns</li>
      The following holds true at least in PostgreSQL 9.2:</p>
      <a href="http://www.postgresql.org/message-id/200611200942.kAK9gwaK029065@wwwmaster.postgresql.org">source</a>
      A FOREIGN KEY constraint does not have to be linked only to a PRIMARY KEY
      constraint in another table; it can also be defined to reference the columns
      of a UNIQUE constraint in another table. A FOREIGN KEY constraint can
      contain null values; however, if any column of a composite FOREIGN KEY
      constraint contains null values, verification of all values that make up the
      FOREIGN KEY constraint is skipped. To make sure that all values of a
      composite FOREIGN KEY constraint are verified, specify NOT NULL on all the
      participating columns.
      <li>how to log SQL statements in PostgreSQL 9.1</li>
      <i>(see also <a href="http://stackoverflow.com/questions/722221/how-to-log-postgres-sql-queries">this SO discussion</a>)</i><p>
        You have to change certain values in file <b>postgres.conf</b> and
        restart the server.<p>
        File <b>postgres.conf</b> is located in: <b>/etc/postgresql/9.1/main/postgresql.conf</b><p>
        Diff of the changes I made is shown below:<p/>
        <pre>
$ diff /etc/postgresql/9.1/main/postgresql.conf.safe.2012-01-15  /etc/postgresql/9.1/main/postgresql.conf
276c276
&lt #log_destination = 'stderr'# Valid values are combinations of
---
  &gt log_destination = 'stderr'# Valid values are combinations of
282c282
  &lt #logging_collector = off# Enable capturing of stderr and csvlog
---
    &gt logging_collector = on# Enable capturing of stderr and csvlog
288c288
    &lt #log_directory = 'pg_log'# directory where log files are written,
---
      &gt log_directory = 'pg_log'# directory where log files are written,
290c290
      &lt #log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'# log file name pattern,
---
        &gt log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'# log file name pattern,
398c398
        &lt #log_statement = 'none'# none, ddl, mod, all
---
          &gt log_statement = 'all'# none, ddl, mod, all

        </pre>
        The log directory (value <b>log_directory</b>) is located relative to the <i>data</i> directory of postgresql which is obtained as follows:<p/>
        <pre>
$ grep -i data /etc/postgresql/9.1/main/postgresql.conf
# option or PGDATA environment variable, represented here as ConfigDir.
data_directory = '/var/lib/postgresql/9.1/main'# use data in another directory
        </pre>
        Once the server is restarted, the SQL queries (DDL and/or DML depending on the settings) can be obtained with:<p/>
        <pre>
sudo -i
tail -f /var/lib/postgresql/9.1/main/pg_log/postgresql-2013-01-15_182646.log 
        </pre>
        <li>useful PostgreSQL functions:</li>
        <pre>
        select current_database();
        select current_schema();
        select current_user;
        select extract('epoch' from now());
        select extract(epoch from now())::integer
        select extract('epoch' from current_timestamp);
        select now();
        select current_timestamp;
        </pre>
        the last two are useful because they reveals the timezone.
        <li>use of the command-line pg_dump utility:</li>
        <pre> pg_dump &ltdatabase&gt -h 172.333.444.555 -p 5444 -U username -F p -E UTF8 -C -O -n %ltschema-name&gt -v -f dumpfile database-name</pre>
        <li>precedence in PostgreSQL pg_hba.conf files</li>
        The general rule of thumb is: <i>Most Specific Rule First</i>
        <li>typical configuration of PostgreSQL 9.1 I am using:</li>
        In file /etc/postgresql/9.1/main/pg_hba.conf:
        <pre>
local   all             all                                 trust
host   all             all   192.168.2.2/24                 md5
        </pre>
        The rationale of <i>local trust</i> being to ensure that I can easily
        add scripts to create users without the hassle of entering
        passwords which is hard to do non-interactively. Remote accesses in
        a specified subnet use <b>md5</b> authentication ofcourse.
        <p>
          And in file /etc/postgresql/9.1/main/postgresql.conf, to enable remote access:
          <pre>listen_addresses = '*'</pre>
          <pre>
listen_addresses = '*'
          </pre>
          <li>Configure PostgreSQL 9.1 to allow password access to users from a specific subdomain
            (say 173.31.0.0/16, i.e. the 173.31 subdomain)</li>
          <pre>
sudo-i
cd /etc/postgresql/9.1/main
          </pre>
          in pg_hba.conf add the following line:
          <pre>
host all all 172.31.0.0/16 md5
          </pre>
          and in file postgresql.conf, change:
          <pre>
listen_addresses='localhost'
          </pre>
          to:
          <pre>
listen_addresses='*'
          </pre>
          <li>Configure PostgreSQL 9.1 to not require password for users</li><p>
            This can be used, e.g. to automate the creation of users by means of a script.
            Basically the following line has to be edited in the pg_hba.conf file:
            <pre>
local   all              all                                trust
            </pre>
            For full reproducibility here's the full <a href="postgresql.html.files/pg_hba.conf.html">pg_hba.conf</a> and the
            <a href="postgresql.html.files/postgresql.conf.html">postgresql.conf</a> configuration files.
            (the second doesn't play any part in this solution and is just provided for completeness
            purposes).
            <li>Configure PostgreSQL 9.1 to accept remote connections</li><p>
              <a href="http://www.cyberciti.biz/tips/postgres-allow-remote-access-tcp-connection.html">original article</a><p>
                It's a two step process:
                <ol type="i">
                  <li>enable client authentication</li>
                  Edit file /etc/postgresql/9.1/main/pg_hba.conf
                  and append the following configuration line to give access to the 192.168.2.0/24
                  network:
                  <pre>
host    all             all             192.168.2.0/24          md5
                  </pre>
                  <li>set the deamon to listen to the network interface</li>
                  Edit file /etc/postgresql/9.1/main/postgresql.conf and add the line:
                  <pre>
listen_addresses = '*'
                  </pre>
                  ... to listen to all the network interfaces.
                </ol>
                After the above steps do a:
                <pre>
sudo /etc/init.d/postgresql restart
                </pre>
                <li>Find Postgresql version</li>
<p>
                Connect as an existing user to an existing database and run the "select version()" query, or from the command line:
                <pre>
psql -Uhr -d ab -c 'select version()'
                </pre>
</p>
<p>&hellip; alternatively, if you don't know the passwords of any existing users but you have <tt>sudo</tt> privilleges, do:
<pre>sudo -u postgres psql postgres -c 'SELECT version()' | grep PostgreSQL
</pre>

</p>
  </ol>


</body>
