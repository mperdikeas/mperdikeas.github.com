<head>
  <link type="text/css" rel="stylesheet" href="mperdikeasgithub.css"/>
  <link rel='icon' href='/knowledge-favicon.ico'/>
</head>
<body>
  <ol reversed class=main-list-items>
    <li>how I setup the postgres user in PostgreSQL 9.5 and created user 'mperdikeas'</li>
    <p>
      PostgreSQL allows one to authenticate using two mechanisms:
      <ul>
        <li>the so called <i>IDENT/PEER</i> authentication which uses UNIX accounts</li>
        <li>the <i>TCP</i> authentication which uses PostgreSQL's own managed username / passwords</li>
      </ul>
      You want to keep the <tt>postgres</tt> UNIX account locked (for security purposes). So I did the following:
      <pre>
sudo passwd --lock postgres</pre>
      &hellip; and subsequently verified that the <tt>postgres</tt> UNIX account is indeed locked by doing:
      <pre>
$ sudo cat /etc/shadow | grep -i postgres
postgres:!*:17117:0:99999:7:::
$ sudo passwd -S postgres
postgres L 11/12/2016 0 99999 7 -1</pre>
    You may read more <a href='https://serverfault.com/a/325596/139074'>here</a>.
    </p>
    <p>
      I then changed the password of the TCP user <tt>postgres</tt> by doing:
      <pre>$ sudo -i -u postgres psql postgres
psql (9.5.19)
Type "help" for help.

postgres=# \password postgres
Enter new password:
Enter it again:</pre>
    </p>
    <p>
      Finally, I created a new TCP user <tt>mperdikeas</tt> and set his password:
      <pre>
$ sudo -i -u postgres createuser --interactive mperdikeas
Shall the new role be a superuser? (y/n) n
Shall the new role be allowed to create databases? (y/n) y
Shall the new role be allowed to create more new roles? (y/n) n
$ sudo -i -u postgres psql
psql (9.5.19)
Type "help" for help.

postgres=# ALTER USER mperdikeas WITH PASSWORD '&lt;redacted&gt;';
ALTER ROLE
postgres=# \q</pre>
    </p>
    <p>
      You will notice that for all administrative commands we are using the UNIX user <tt>postgres</tt>
    </p>
    <p>
      <span class='nb'>NB:</span> be sure to set the authentication method to 'md5' in the following file:
      <pre>/etc/postgresql/9.5/main/pg_hba.conf</pre>
      (allowed values are <i>trust</i>, <i>peer</i> and <i>md5</i>)
    </p>
    <li><a href='http://serverfault.com/a/325596/139074'>why you shouldn't change the password of the <tt>postgres</tt> Linux user using <tt>sudo passwd postgres</tt></a>
    <li><a href='postgresql.html.files/install-postgresql9.5-in-Ubuntu-14.04-trusty-thar.html'>Install Postgresql 9.5 in Ubuntu 14.04 Trusty Tahr</a></li>
    <li><a href='postgresql.html.files/timstamp-with-or-without-timezone.html'>timestamps with or without timezones</a></li>
    <li>how to write recursive SQL WITH queries</li>
    <p>Today I implemented the following SSCCE to dig recursive WITH queries:</p>
    <p>Let's first define a simple schema to represent trees so we can motivate
      a use case of recursive queries.<br/>
      We can imagine having two tables to represent two kinds of nodes:
      <ul>
        <li>"proper" nodes</li>
        <li>leaf nodes, which can hang under any "proper" node (including internal ones)</li>
      </ul>
    </p>
    <p>
      A possible approach would be the following:
      <pre>
    DROP TABLE IF EXISTS leaf;
    DROP TABLE IF EXISTS node;

    CREATE TABLE node (
        i         INTEGER NOT NULL,
        parent    INTEGER     NULL
    );
    ALTER TABLE node ADD PRIMARY KEY(i);

    CREATE TABLE leaf (
        i         SERIAL,
        leafName  VARCHAR NOT NULL,
        underNode INTEGER NOT NULL);
    ALTER TABLE leaf ADD PRIMARY KEY (i);
    ALTER TABLE leaf ADD FOREIGN KEY (underNode) REFERENCES node(i);
      </pre>
    </p>
    <p>One can imagine the above schema to be populated with the below test data:
      <pre>
    INSERT INTO node VALUES
    (1, NULL), (2, NULL), (3, 1), (5, 1), (7, 1), (4, 2), (6, 2);

    INSERT INTO leaf(leafName, underNode) VALUES
    ('leaf under 1', 1), ('leaf under 2', 2), ('leaf under 3', 3), ('leaf under 5', 5), ('leaf under 7', 7);
      </pre>
    </p>
    <p>Given the above, the following query fetches the names of all leaves hanging under the 'subtree'
      of node with key #1:
      <pre>
    WITH RECURSIVE NODES_IN_SUBTREE (i) AS (
        VALUES (1)
        UNION ALL SELECT a.i FROM NODES_IN_SUBTREE INNER JOIN node a
        ON a.parent = NODES_IN_SUBTREE.i
    )
    SELECT leafName FROM leaf
    WHERE underNode IN (SELECT i FROM NODES_IN_SUBTREE);
      </pre>
    </p>
    <p>
      &hellip; and the following query fetches all leaves that live under the 'subtrees' of all nodes who are children
      of the root of the tree (therefore, effectively fetches <b>all</b> leaves in the tree):
      <pre>
    WITH RECURSIVE NODES_IN_SUBTREE (i) AS (
        (SELECT i FROM node WHERE parent IS NULL)
        UNION ALL SELECT a.i FROM NODES_IN_SUBTREE INNER JOIN node a
        ON a.parent = NODES_IN_SUBTREE.i
    )
    SELECT leafName FROM leaf
    WHERE underNode IN (SELECT i FROM NODES_IN_SUBTREE);
      </pre>
    </p>
    <li>how to create superuser "<b>postgres</b>" if none exists when the PostgreSQL is built from sources</li>
    <a href='#typical-access-control-configurations'>relevant note</a>
    <br/>
    On 2016-04-20 I faced the following situation: a colleague built and configured a PostgreSQL 9.4 cluster
    on my home directory and apparently no superuser 'postgres' was created. The steps the colleague executed
    were the bold ones from the following:
    <ol>
      <li><b>      ./configure</b></li>
      <li><b>      make</b></li>
      <li><b>      su</b></li>
      <li><b>      make install</b></li>
      <li>      adduser postgres</li>
      <li><b>      mkdir /usr/local/pgsql/data</b></li>
      <li>      chown postgres /usr/local/pgsql/data</li>
      <li>      su - postgres</li>
      <li><b>      /usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</b></li>
      <li>      /usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data >logfile 2>&1 &</li>
      <li>      /usr/local/pgsql/bin/createdb test</li>
      <li>      /usr/local/pgsql/bin/psql test</li>
    </ol>
    <br/>
    Except for the fact that the path was not <tt>/usr/local/pgsql</tt>, but rather <tt>~/postgresql-9.4.5</tt>.
    <br/>
    <br/>Also, the command at item #10 is just to start the database cluster server. Instead I could start the server
    myself with the following:
    <pre>./postgres-9.4.5/bin/postgres -D ./postgres-9.4.5/data/</pre>

    The main problem that there was no superuser which I could use to connect to the PostgreSQL cluster (using <tt>psql</tt>)
    and from there on to create my own project-specific database and user.
    <br/><br/>
    To that end, I created a user <tt>postgres</tt> as follows:
    <pre>createuser --interactive postgres</pre>

    <br/>... and proceed to answer "yes" to the question whether the user ought to be a superuser.
    <br/>
    <br/>
    <div id='edit-of-pg_hba.conf-9.4.5'>
    I then changed <tt>~/postgres-9.4.5/data/pg_hba.conf</tt>
      to contain:
      <pre>
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            md5
# IPv6 local connections:
host    all             all             ::1/128                 md5

</pre></div>
<br/>... and then connected as user <tt>postgres</tt> and changed its password to:
<pre>
$ which psql
~/postgres9/bin/psql
rawdar@radacerd:~#
$ psql -U postgres
psql (9.4.5)
Type "help" for help.

postgres=# alter user postgres password 'secret';
</pre>
<br/>... even though that was not strictly necessary as I was only connecting as user <tt>postgres</tt>
using <tt>psql</tt> which uses Unix domain sockets and thus falls under the <tt>trust</tt> model.
<br/><br/>
Following the above I was able to run my subsequent (domain-specific) scripts that created the project
user and its database (and which rely on <tt>psql</tt> access with the superuser <tt>postgres</tt>).
<br/><br/>
What I understood from the above is that when PostgreSQL 9.4 is created in the home directory of an arbitrary
user there's nothing special about the <tt>postgres</tt> user, any superuser who can create additional roles
and databases will do.
<br/>
<br/>
Note in the above connection that <tt>postgres</tt> is a user of the PostgreSQL cluster
(or, more correctly, a <tt>role</tt>) and not a Unix/Linux system user.
    <li>how to configure retention of unresponsive TCP connections in PostgreSQL</li>
    I've used the following settings:
    <pre>
#tcp_keepalives_idle = 0                # TCP_KEEPIDLE, in seconds;
                                        # 0 selects the system default
tcp_keepalives_idle = 200               # TCP_KEEPIDLE, in seconds;
#tcp_keepalives_interval = 0            # TCP_KEEPINTVL, in seconds;
                                        # 0 selects the system default
tcp_keepalives_interval = 30            # TCP_KEEPINTVL, in seconds;
#tcp_keepalives_count = 0               # TCP_KEEPCNT;
                                        # 0 selects the system default
tcp_keepalives_count = 10               # TCP_KEEPCNT;

    </pre>
    ...in this file: <tt>/postgresDB/data-9.1.14/postgresql.conf</tt> at
    the new EuroVO registry PostgreSQL cluster.
    <br/>
    Sources:
    <br/>
<a href='http://stackoverflow.com/a/2186617/274677'>SO</a>, <a href='http://www.gnugk.org/keepalive.html'>GNU Gatekeeper keepalive page</a>
    <li>how to kill non-responsive PostgreSQL queries</li>
    <pre>
    select pg_terminate_backend(procpid)
    from pg_stat_activity
    where usename = 'yourusername'
     and current_query = '&lt;IDLE&gt;'
     and query_start < current_timestamp - interval '5 minutes'
     ;
    </pre>
    <a href='http://serverfault.com/a/577722/139074'>source</a>
    <li>how to query PostgreSQL for currently executing queries</li>
    <ul>
      <li>Using the <tt>pg_stat_activity</tt> table</li>
      This method requires no installation (but I've never managed to extract much useful information from it):
      <pre>SELECT * FROM pg_stat_activity</pre>
      <li>Using the <tt>pg_stat_statements</tt> table</li>
      This method requires the installation of some additional libraries as described <a href="http://dba.stackexchange.com/q/124054/34332">in this dba.stackexchange post</a> but offers more useful information:
      <pre>SELECT * FROM pg_stat_statements ORDER BY total_time DESC </pre>
    </ul>
    <li>sample configuration files used</li>
    <dl>
      <dt><strong>postgresql.conf</strong></dt>
      <dd>
        <ol>
          <li>PostgreSQL 9.3 in Ubuntu 14.04 (NP desktop)</dt></li>
          Residing in: <a href="postgres9_3-NP-desktop-postgresql.conf">/etc/postgresql/9.3/main/postgresql.conf</a>
          <br/>
          <strong>NB:</strong> not to be confused with the <tt>postgresql.conf.sample</tt> file
          residing in:
          <br/>
          <tt>/usr/share/postgresql</tt>
          <br/>
          ... of which I had made a copy named <tt>postgresql.conf</tt> that led to the confusion reported in
          <a href="http://dba.stackexchange.com/q/124852/34332">this StackOverflow post</a>.
        </ol>
      </dd>
      <dt><strong>pg_hba.conf</strong></dt>
      <dd>
        <ol>
          <li>PostgreSQL 9.3 in Ubuntu 14.04 (NP desktop)</dt></li>
          Residing in: <a href="postgres9_3-NP-desktop-pg_hba.conf">/etc/postgresql/9.3/main/pg_hba.conf</a>
        </ol>
      </dd>      
    </dl>
    <li>awesome PostgreSQL CLI client with auto-completion and syntax highlighting</li>
    Source: <a href="https://github.com/dbcli/pgcli">https://github.com/dbcli/pgcli</a>
    <pre>
sudo apt-get install python-pip
sudo apt-get install python-dev libpq-dev libevent-dev
sudo pip install pgcli
    </pre>
    <li>how to convert VARCHAR data to XML so that the XPATH function may be used on them</li>
    Use the <tt>XMLPARSE</tt> function:
    <pre>
SELECT DISTINCT CAST (XPATH('@status',XMLPARSE(CONTENT "content")) AS VARCHAR), isdeleted
FROM vo_business.hosted_record_version
    </pre>
    <li>During PostgreSQL startup: <tt>could not open file "/etc/ssl/private/ssl-cert-snakeoil.key": Permission denied</tt></li>
    Encountered this problem for PostgreSQL 9.1 on Ubuntu 12.04.<br/>
    The following solution worked for me:
    <pre>
sudo chown postgres /etc/ssl/private/ssl-cert-snakeoil.key
sudo chown postgres /etc/ssl/certs/ssl-cert-snakeoil.pem
    </pre>
    <li>Install PostgreSQL From Its Official Repository in Ubuntu 14.04</li>
    The PostgreSQL Global Development Group (PGDG) maintains an APT repository of PostgreSQL packages for Debian and Ubuntu. The repository provides the PostgreSQL server packages as well as extensions and modules packages for all PostgreSQL versions supported.
    <br/>
    So far, the repository support:
    <ul>
      <li>Debian 6.0 (squeeze), 7.0 (wheezy), and unstable (sid) 64/32 bit (amd64/i386)</li>
      <li>Ubuntu 10.04 (lucid), 12.04 (precise), and 14.04 (trusty) 64/32 bit (amd64/i386)</li>
      <li>PostgreSQL 8.4, 9.0, 9.1, 9.2, 9.3</li>
      <li>Server extensions such as Slony-I, various PL languages, and datatypes</li>
      <li>Applications like pgadmin3, pgbouncer, and pgpool-II</li>
    </ul>
    To get started installing PostgreSQL on Ubuntu 14.04, do the following steps:
    <ol>
      <li>Create and edit the PostgreSQL repository by running the command below:</li>
      <pre>
sudo emacs -nw /etc/apt/sources.list.d/pgdg.list
      </pre>
      Insert the following line:
      <pre>
deb http://apt.postgresql.org/pub/repos/apt/ trusty-pgdg main
      </pre>
      <li>Download & import the repository key:</li>
      <pre>
wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
      </pre>
      <li>Update your system:</li>
      <pre>
sudo apt-get update && sudo apt-get upgrade
      </pre>
      <li>Now you're able to install PostgreSQL via below command:</li>
      <pre>
sudo apt-get install postgresql-9.3 pgadmin3
      </pre>
    </ol>
    <b>NB:</b> This repository provides <tt>postgresql</tt>, <tt>postgresql-contrib</tt>, and <tt>postgresql-client</tt> meta-packages that depend on the latest <i>postgresql-x.y</i> packages, similar to the ones present in Debian and Ubuntu. Once a new PostgreSQL version is released, these meta-packages will be updated to depend on the new version. If you rather want to stay with a particular PostgreSQL version, you should install specific packages like <tt>postgresql-9.3</tt> instead of <tt>postgresql</tt>.
    <br/>
    <a href="http://ubuntuhandbook.org/index.php/2014/02/install-postgresql-ubuntu-14-04/">source</a>
    <li>how to execute PL/pgSQL blocks, function definitions, transactions in DbVisualizer</li>
    Instead of the <i>Execute</i> or <i>Execute Current</i> options, use the <i>Execute Buffer</i>
    as shown in the screenshot below:
    <br/>
    <a href="dbvis-execute-buffer.png">
      <img height="200px" width="300px" src="dbvis-execute-buffer.png"/>
    </a>.
    <li>examining (and terminating, if need be) user sessions</li>
    Sometimes you just need to kill a user session (e.g. that may be preventing your from droping and recreating your database).
    Restarting PostgreSQL is one option. A more fine-grained one is to kill the user sessions.
    <br/>
    Start by examining user sessions:
    <pre>SELECT * FROM pg_stat_activity;</pre>
    Cancel the backend process (gentle):
    <pre>SELECT pg_cancel_backend( <procpid> );</pre>
      &hellip; if the above doesn't work (it didn't in my case), try the more forceful:
      <pre>
SELECT pg_terminate_backend( <procpid> );
      </pre>
      <a href="http://www.devopsderek.com/blog/2012/11/13/list-and-disconnect-postgresql-db-sessions/">source</a>
      <li>configuration of logging directory in Postgresql (in Ubuntu 12.04)</li>
      This is where it's done:
      <pre>
sudo cat /etc/postgresql/9.1/main/postgresql.conf | grep log_directory
      </pre>
      <li>yet more complex XPath example</li>
      <pre>
SELECT
DISTINCT ivoid, CAST(xpath('//*[local-name()=''capability'' and @xsi:type=''ssa:SimpleSpectralAccess'']/*[local-name()=''testQuery'']' , content, ARRAY[ARRAY['xsi', 'http://www.w3.org/2001/XMLSchema-instance']]) AS VARCHAR)
FROM rr.resourcecontent
WHERE CAST(xpath('//*[local-name()=''capability'' and @xsi:type=''ssa:SimpleSpectralAccess'']/*[local-name()=''testQuery'']' , content, ARRAY[ARRAY['xsi', 'http://www.w3.org/2001/XMLSchema-instance']]) AS VARCHAR)!='{}'
      </pre>
      <li>complex XPath example demonstrating namespace-agnostic <i>local-name</i>, testing if a value belongs in a list, and need to CAST from XML to VARCHAR</li>
      <pre>
SELECT 
CAST(xpath('//*[local-name()=''capability'' and (@standardID=''ivo://ivoa.net/std/SIA'' or @standardID=''ivo://ivoa.net/std/SSA'')]/@standardID' , content) AS VARCHAR), count(*)
FROM someschema.sometable
GROUP BY CAST(xpath('//*[local-name()=''capability'' and (@standardID=''ivo://ivoa.net/std/SIA'' or @standardID=''ivo://ivoa.net/std/SSA'')]/@standardID' , content) AS VARCHAR)
      </pre>
      <li>downloading the results of a SQL query on local filesystem</li>
      <a href="http://stackoverflow.com/a/11870348/274677">source</a><br/>
      Example:<br/>
      <pre>
psql -d RegTAP -t -A -F"," -c "SELECT pregraft FROM vo_business.harvest_record WHERE recordivoid='ivo://irsa.ipac/Spitzer/Images/SINGS'" > pregraft
      </pre>
      <li>using XPath with namespaces in PostgreSQL</li>
      <a href="http://www.postgresql.org/docs/9.1/static/functions-xml.html">PostgreSQL 9.1 docs</a>
      <br/>
      Example (including also a cast):<br/>
      <pre>
SELECT ivoidlowercase, xpath('@xsi:type', content, ARRAY[ARRAY['xsi', 'http://www.w3.org/2001/XMLSchema-instance']])
FROM rr.resourcecontent 
WHERE lower(CAST (xpath('@xsi:type', content, ARRAY[ARRAY['xsi', 'http://www.w3.org/2001/XMLSchema-instance']]) AS VARCHAR)) LIKE '%vs:dataservice%'
      </pre>
      <li id='typical-access-control-configurations'>typical access control configurations</li>
      The rationale is the following:
      <ul>
        <li>trust all local UNIX-domain sockets (that tools like <b>psql</b> are using to create database and user
          in the various scripts)</li>
        <li>configure password-based authentication (md5) for TCP/IP sockets</li>
      </ul>
      <br/>
      E.g. (as found in my SAT machine)
      <pre>
$ sudo cat /etc/postgresql/9.1/main/pg_hba.conf  | grep -v ^# | uniq

local   all             postgres                                trust
local   all             all                                     trust
host    all             all             127.0.0.1/32            md5
host    all             all             ::1/128                 md5

      </pre>
      <li>Terminology on <i>clusters</i>, <i>catalogs</i>, <i>databases</i> and <i>schemas</i></li>
      <a href="http://stackoverflow.com/a/17943883/274677">source</a>
      <br/>
      A <b>cluster</b> in Postgres is simply a Postgres installation. Cluster here is not meant in the hardware sense of
      multiple computers working together. In Postgres, cluster refers to the fact that you can multiple unrelated databases all up and
      running using the same Postgres server engine. So, in other words, a <b>cluster</b> is a database server.
      <br/>
      So in both Postgres and the SQL Standard we have this containment hierarchy:
      <ul>
        <li>A computer may have one or multiple <b>clusters</b>.</li>
        <li>A database server is a cluster.</li>
        <li>A cluster has <b>catalogs</b>. ( Catalog = <b>Database</b> )</li>
        <li>Catalogs have <b>schemas</b>. (Schema = namespace of tables, and security boundary)</li>
        <li>Schemas have <b>tables</b>.</li>
        <li>Tables have <b>rows</b>.</li>
        <li>Rows have <b>values</b>, defined by columns.</li>
      </ul>
      The drawing below sums it up nicely:
      <br/>
      <img src="postgres-cluster-catalog-schemas.png">



      <li>online SQL playground / sandbox</li>
      <a href="http://sqlfiddle.com/">SQL fiddle</a>
      <li>Window functions (latest installment)</li>
      New insight into the logic of window functions:
      <ul>
        <li>The <b>PARTITION</b> clause defines the window, however some functions by default operate on a concept called the 'frame' which may by, default include less than the full window
          E.g. see what <a href="http://www.postgresql.org/docs/9.2/static/functions-window.html"> postgreSQL</a> says:
          <br/><i>
            Note that first_value, last_value, and nth_value consider only the rows within the "window frame", which by default contains the rows from the start of the partition through the last peer of the current row. This is likely to give unhelpful results for last_value and sometimes also nth_value. You can redefine the frame by adding a suitable frame specification (RANGE or ROWS) to the OVER clause. See Section 4.2.8 for more information about frame specifications.
          </i>
          <br/>
        </li>
        <li>In the same vein:
          <ul>
            <li><b>over (order by x)</b></li>
            is really shortcut for:
            <li><b>over (order by x rows between unbounded preceding and current row)</b></li>
            ... and so, sometimes (see example below), the below form is needed:
            <li><b>over (order by x rows between unbounded preceding and unbounded following</b></li>
          </ul>
        </li>
        <li>helpful site and other links:
          <ul>
            <li><a href="http://tapoueh.org/blog/2013/08/20-Window-Functions">3rd-party turotial on window functions</a></li>
            <li><a href="http://www.postgresql.org/docs/9.1/static/tutorial-window.html">PostgreSQL tutorial</a></li>
            <li><a href="http://www.postgresql.org/docs/9.2/static/functions-window.html">PostgreSQL window functions</a></li>
            <li><a href="http://www.postgresql.org/docs/9.2/static/functions-aggregate.html">PostgreSQL aggregate functions</a></li>
          </ul>
        </li>
      </ul>
      <br/>
      Some instructive examples follow:
      <br/>
      <pre>
-- order by x means "order by x rows between unbounded preceding and current row
select x, array_agg(x) over (rows between unbounded preceding and current row) from generate_series(1, 10) AS t(x)
select x, array_agg(x) over (order by x rows between unbounded preceding and current row) from generate_series(1, 10) AS t(x)
select x, array_agg(x) over (order by x) from generate_series(1, 10) AS t(x)

select foo.*, first_value(i) over (partition by a order by i desc) from foo

select foo.*, lag(i) over (partition by a order by i asc) from foo

select foo.*, lag(i, 2) over (partition by a order by i asc) from foo
select foo.*, lag(i, 2, -1) over (partition by a order by i asc) from foo

select x, array_agg(x) over (rows between current row and unbounded following) from generate_series(1, 10) AS t(x)
select x, array_agg(x) over () from generate_series(1, 10) AS t(x)
select x, array_agg(x) over (order by x) from generate_series(1, 10) AS t(x)

CREATE TABLE employee_salary(employee VARCHAR, department VARCHAR, salary INTEGER);
INSERT INTO employee_salary
VALUES
('mike', 'sales',  90000),
('john', 'sales', 130000),
('paul', 'sales',  70000),
('anna', 'dev'  ,  20000),
('peter','dev'  ,  50000)

SELECT employee, salary, department,
round(AVG(salary) OVER (PARTITION BY department),0) AS average_dept_salary,
rank() OVER (PARTITION BY department ORDER BY salary DESC) AS salary_rank,
lead(salary) OVER (PARTITION BY department ORDER BY salary ASC) AS next_higher,
lag (salary) OVER (PARTITION BY department ORDER BY salary ASC) AS prev_lower,
first_value(salary) OVER (PARTITION BY department ORDER BY salary ASC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS lowest_salary_in_department,
last_value (salary) OVER (PARTITION BY department ORDER BY salary ASC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS highest_salary_in_department
FROM employee_salary
      </pre>

      <li>how to install <b>pgsphere</b></li>
      I followed the instructions from <a href="http://pgsphere.projects.pgfoundry.org">the pgSphere 1.1 project site</a>
      with the following qualifications and log:
      <ol type="i">
        <li>downloaded pgSphere sources from <a href="http://pgfoundry.org/projects/pgsphere/">the pgSphere homepage</a></li>
        <pre>
    wget http://pgfoundry.org/frs/download.php/2558/pgsphere-1.1.1.tar.gz
        </pre>
        <li>I opted for the <i>second way</i> to compile <b>pgSphere</b> (as instructed in <a href="http://pgsphere.projects.pgfoundry.org/x44.html">the installation instructions page</a>), which is the one that does not require the PostgreSQL sources but, instead, the configuration tool <b>pg_config</b></li>
        <li>since <b>pg_config</b> didn't exist I installed it by executing:
          <pre>
sudo apt-cache search postgresql-server-dev
sudo apt-get install postgresql-server-dev-9.1
          </pre>
          Now, <b>pg_config</b> is installed and its location can be got with:<pre>which pg_config</pre> (we use that location below)
        </li>
        <li>expand the pgSphere tarball we downloaded and cd into the directory that's created:
          <pre>
tar xvfz pgsphere-1.1.1.tar.gz
cd pgsphere-1.1.1/
          </pre>
        </li>
        <li>follow the installation instructions linked above ("<i>second way</i>"), replacing "/path/to/pg_config" with the actual path</li>
        <pre>
make USE_PGXS=1 PG_CONFIG=/usr/bin/pg_config
sudo make USE_PGXS=1 PG_CONFIG=/usr/bin/pg_config install
        </pre>
        <li>when I tried to check the installation as instructed:
          <br/><br/><i>To check the installation change into the pg_sphere source directory again and run:
            <br/>
            shell> make installcheck
          </i><br/><br/>... I got the following error trace:
          <pre>
Makefile:29: ../../src/Makefile.global: No such file or directory
Makefile:30: /contrib/contrib-global.mk: No such file or directory
make: *** No rule to make target `/contrib/contrib-global.mk'.  Stop.
          </pre>
          ... but the installation was successful nonetheless because I was able to execute the last step as
          advised in "<i>2.3. Creating a database with pgSphere</i>" of the installation instructions linked above with:
          <pre>
psql -U postgres -d RegTAP -f ./pg_sphere.sql
          </pre>
      </ol>
      <li>Window functions (cont.)</li>
      Note that <b>PARTITION</b> is not the function to be used in the <b>OVER</b> clause, <b>ORDER</b> is also available.
      E.g. to produce a salary rank for each employee according to his salary (the rank of '1' being assigned to the
      highest salary), one can do a:
      <pre>
SELECT emp_name, salary, RANK() OVER (ORDER BY salary DESC) AS sal_pos 
FROM test_curation.employee
ORDER BY sal_pos ASC
      </pre>

      (contrast the results, with those one gets when using <b>ROW_NUMBER()</b> instead of <b>RANK</b>)

      This can allow us to obtain the three highest paid employees, where using the simpler <b>LIMIT</b>
      clause of PostgreSQL would fail because of the tie on the third rank (Elizabeth and Flora).
      The below simple approach shows only one of the two employees with a salary of 4:

      <pre>
SELECT emp_name, salary
FROM test_curation.employee
ORDER BY salary DESC
LIMIT 3
      </pre>

      ... whereas using the window function <b>RANK()</b> one is able to get both of them:

      <pre>
SELECT x.* FROM (
SELECT emp_name, salary, rank() OVER (ORDER BY salary DESC) AS sal_pos 
FROM test_curation.employee
ORDER BY sal_pos ASC) x
WHERE x.sal_pos<=3
      </pre>
      <br/>
      There is also the <b>DENSE_RANK()</b> function which continues counting, in case of ties, 
      from the exactly previous rank (whereas <b>RANK()</b> in case of ties leaves a gap as wide
      as the number of tied elements).

      <li>Window functions rock!</li>
      <pre>
DROP TABLE IF EXISTS test_curation.employee;
CREATE TABLE test_curation.employee (
department VARCHAR,
emp_name VARCHAR,
salary INTEGER);

INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('SALES', 'MIKE', 3);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('SALES', 'MARJORIE', 5);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('SALES', 'ELIZABETH', 4);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('SALES', 'FLORA', 4);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('DEV', 'THOMAS', 10);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('DEV', 'GEORGE', 2);
INSERT INTO test_curation.employee(department, emp_name, salary) VALUES ('DEV', 'MENELAUS', 1);

-- simple example to demonstrate the use of the window function AVG
SELECT department, emp_name, AVG(salary) OVER (PARTITION BY department), rank() OVER (PARTITION BY department ORDER BY salary DESC)
FROM test_curation.employee;

-- using the window function rank, observe that both Elizabeth and Flora appear as rank() assigns the same number
-- in case of ties
SELECT department, emp_name, salary, avg FROM
(SELECT department, emp_name, salary, AVG(salary) OVER (PARTITION BY department), rank() OVER (PARTITION BY department ORDER BY salary DESC)
FROM test_curation.employee) r
WHERE rank<=2;

-- rank() assigns the same number in case of ties() and also leaves gaps right after a tie:
SELECT department, emp_name, salary, avg FROM
(SELECT department, emp_name, salary, AVG(salary) OVER (PARTITION BY department), rank() OVER (PARTITION BY department ORDER BY salary DESC)
FROM test_curation.employee) r
WHERE rank=3;

-- row_number() always assigns different numbers and in case of a tie one row is chosen based on some arbitrary criterion (e.g. actual order fetched maybe?)
SELECT department, emp_name, salary, avg FROM
(SELECT department, emp_name, salary, AVG(salary) OVER (PARTITION BY department), row_number() OVER (PARTITION BY department ORDER BY salary DESC)
FROM test_curation.employee) r
WHERE row_number<=2;
      </pre>
      <li>PostgreSQL-specific way to get maximum or minimum values of certain columns for every combination of other columns</li>
      This is using the PostgreSQL-specific <b>DISTINCT ON</b> syntax (an extension on the SQL standard <b>DISTINCT</b> for specific
      columns).
      <br>
      Given the below table:
      <pre>
CREATE TABLE A (A1 INTEGER, A2 INTEGER, A3 INTEGER);

INSERT INTO A(A1, A2, A3) VALUES (1, 1, 1);
INSERT INTO A(A1, A2, A3) VALUES (2, 1, 1);
INSERT INTO A(A1, A2, A3) VALUES (2, 1, 2);
INSERT INTO A(A1, A2, A3) VALUES (3, 1, 2);
INSERT INTO A(A1, A2, A3) VALUES (2, 1, 2);
INSERT INTO A(A1, A2, A3) VALUES (4, 1, 2);
INSERT INTO A(A1, A2, A3) VALUES (4, 1, 5);
INSERT INTO A(A1, A2, A3) VALUES (3, 1, 5);
      </pre>
      The following obtains minimum <b>a1</b> values for every combination of <b>a2</b> and <b>a3</b>:
      <pre>
SELECT DISTINCT ON (a2, a3) a2, a3, a1 FROM A ORDER BY a2, a3, a1
      </pre>
      <br>Whereas the following does the same, for maximum <b>a1</b> values:
      <pre>
SELECT DISTINCT ON (a2, a3) a2, a3, a1 FROM A ORDER BY a2, a3, a1 DESC
      </pre>

      <li>how to drop a database in PostgreSQL</li>
      Three ways:
      <ol type="i">
        <li>command line only:</li>
        <pre>dropdb &ltdatabase name&gt</pre>
        <li>more refined, once connected as <i>postgres</i> superuser:</li>
        <pre>DROP DATABASE IF EXISTS &ltdatabase name&gt</pre>
        <li>the way above from the command line:</li>
        <pre>psql -U postgres postgres -f &ltfile with the above script&gt</pre>
      </ol>
      <li>how to handle namespace prefixes in <b>xpath</b> queries</li>
      Simple case (1 namespace prefix):
      <pre>
SELECT ( CAST (xpath('/*/@xsi:type', content, array[array['xsi', 'http://www.w3.org/2001/XMLSchema-instance']]) AS TEXT[]))[1] from rr.resourcecontent
      </pre>
      <br/>More complicated case (2 namespace prefixes):
      <pre>
SELECT ( CAST (xpath('/ri:Resource/@xsi:type', content, array[array['xsi', 'http://www.w3.org/2001/XMLSchema-instance'],
                                                              array['ri', 'http://www.ivoa.net/xml/RegistryInterface/v1.0']]) AS TEXT[]))[1] from rr.resourcecontent
      </pre>
      <li>another very useful syntax for doing <b>xpath</b> in PostgreSQL</li>
      Basic idea is that we cast the xpath result to a text array and we take the first element (that's
      when we know that the xpath expression will return a single value only):
      <pre>
SELECT ( CAST (xpath('/*/identifier', content) AS TEXT[]))[1] from rr.resourcecontent
      </pre>
      <li>how to check if a value appears in an array</li>
      The expression below evals to <b>true</b>
      <pre>
select 'a' = ANY ('{a , b}'::varchar[])
      </pre>
      <li>how to use <b>xpath</b> in where clauses in PostgreSQL</li>
      <b>xpath</b> types cannot be directly compared to string literals, so one has to do a cast, e.g.:
      <pre>
select count(*) from rr.resourcecontent where cast (xpath('/*/capability/@standardID', content) as text[])='{ivo://ivoa.net/std/ConeSearch}'
      </pre>
      - or - <i>(to allow use of PostgreSQL <b>trim</b> function - but only if only one item is returned)</i>:
      <pre>
select count(*) from rr.resourcecontent where trim( cast (xpath('/*/capability/@standardID', content) as text))='{ivo://ivoa.net/std/ConeSearch}'
      </pre>
      - or - <i>(if an array of values may be returned by the XPath expression)</i>:
      <pre>
select count(*) from rr.resourcecontent where 'ivo://ivoa.net/std/ConeSearch' = ANY (cast (xpath('/*/capability/@standardID', content) as text[]) )
      </pre>
      (I haven't found a way how to cast to a text array <b>and</b> do a <b>trim()</b> at the same time).
      <li>various types of inserts in PostgreSQL</li>
      A good report comparing:
      <ol type=a>
        <li>VSI - very silly inserts (executing queries made by concatenated Strings, one-by-one)</li>
        <li>SPI - stupid prepared inserts (executing queries made by Prepared Inserts one-by-one)</li>
        <li>BPI - batch prepared inserts (executing queries made by Prepared Inserts in batches)</li>
        <li>CPI - copy inserts (using the 'properietary' COPY FROM API offered by PostgreSQL driver)</li>
      </ol>
      </p> ... is given <a href="http://rostislav-matl.blogspot.com.es/2011/08/fast-inserts-to-postgresql-with-jdbc.html">here</a>.
      Results graph is:</p><img src="inserts-linechart.png">
      </p>My take is that BPIs are good enough without having to venture out onto non-standard CPI-land.
      <br>Caveat: according to <a href="http://stackoverflow.com/questions/12012592/jdbc-insert-multiple-rows">this SO discussion</a>
      auto commit should be set to false for 
      BPI to offer any advantage over SPI (setting auto commit to false is one JDBC's best practices anyway).

      <li>location of <b>pg_ctl</b> in Postgresql 9.2</li>
      <pre>/usr/lib/postgresql/9.2/bin/pg_ctl</pre>
      <li>NULL values in foreign key columns</li>
      The following holds true at least in PostgreSQL 9.2:</p>
      <a href="http://www.postgresql.org/message-id/200611200942.kAK9gwaK029065@wwwmaster.postgresql.org">source</a>
      A FOREIGN KEY constraint does not have to be linked only to a PRIMARY KEY
      constraint in another table; it can also be defined to reference the columns
      of a UNIQUE constraint in another table. A FOREIGN KEY constraint can
      contain null values; however, if any column of a composite FOREIGN KEY
      constraint contains null values, verification of all values that make up the
      FOREIGN KEY constraint is skipped. To make sure that all values of a
      composite FOREIGN KEY constraint are verified, specify NOT NULL on all the
      participating columns.
      <li>how to log SQL statements in PostgreSQL 9.1</li>
      <i>(see also <a href="http://stackoverflow.com/questions/722221/how-to-log-postgres-sql-queries">this SO discussion</a>)</i><p>
        You have to change certain values in file <b>postgres.conf</b> and
        restart the server.<p>
        File <b>postgres.conf</b> is located in: <b>/etc/postgresql/9.1/main/postgresql.conf</b><p>
        Diff of the changes I made is shown below:<p/>
        <pre>
$ diff /etc/postgresql/9.1/main/postgresql.conf.safe.2012-01-15  /etc/postgresql/9.1/main/postgresql.conf
276c276
&lt #log_destination = 'stderr'# Valid values are combinations of
---
  &gt log_destination = 'stderr'# Valid values are combinations of
282c282
  &lt #logging_collector = off# Enable capturing of stderr and csvlog
---
    &gt logging_collector = on# Enable capturing of stderr and csvlog
288c288
    &lt #log_directory = 'pg_log'# directory where log files are written,
---
      &gt log_directory = 'pg_log'# directory where log files are written,
290c290
      &lt #log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'# log file name pattern,
---
        &gt log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'# log file name pattern,
398c398
        &lt #log_statement = 'none'# none, ddl, mod, all
---
          &gt log_statement = 'all'# none, ddl, mod, all

        </pre>
        The log directory (value <b>log_directory</b>) is located relative to the <i>data</i> directory of postgresql which is obtained as follows:<p/>
        <pre>
$ grep -i data /etc/postgresql/9.1/main/postgresql.conf
# option or PGDATA environment variable, represented here as ConfigDir.
data_directory = '/var/lib/postgresql/9.1/main'# use data in another directory
        </pre>
        Once the server is restarted, the SQL queries (DDL and/or DML depending on the settings) can be obtained with:<p/>
        <pre>
sudo -i
tail -f /var/lib/postgresql/9.1/main/pg_log/postgresql-2013-01-15_182646.log 
        </pre>
        <li>useful PostgreSQL functions:</li>
        <pre>
        select current_database();
        select current_schema();
        select current_user;
        select extract('epoch' from now());
        select extract(epoch from now())::integer
        select extract('epoch' from current_timestamp);
        select now();
        select current_timestamp;
        </pre>
        the last two are useful because they reveals the timezone.
        <li>use of the command-line pg_dump utility:</li>
        <pre> pg_dump &ltdatabase&gt -h 172.333.444.555 -p 5444 -U username -F p -E UTF8 -C -O -n %ltschema-name&gt -v -f dumpfile database-name</pre>
        <li>precedence in PostgreSQL pg_hba.conf files</li>
        The general rule of thumb is: <i>Most Specific Rule First</i>
        <li>typical configuration of PostgreSQL 9.1 I am using:</li>
        In file /etc/postgresql/9.1/main/pg_hba.conf:
        <pre>
local   all             all                                 trust
host   all             all   192.168.2.2/24                 md5
        </pre>
        The rationale of <i>local trust</i> being to ensure that I can easily
        add scripts to create users without the hassle of entering
        passwords which is hard to do non-interactively. Remote accesses in
        a specified subnet use <b>md5</b> authentication ofcourse.
        <p>
          And in file /etc/postgresql/9.1/main/postgresql.conf, to enable remote access:
          <pre>listen_addresses = '*'</pre>
          <pre>
listen_addresses = '*'
          </pre>
          <li>Configure PostgreSQL 9.1 to allow password access to users from a specific subdomain
            (say 173.31.0.0/16, i.e. the 173.31 subdomain)</li>
          <pre>
sudo-i
cd /etc/postgresql/9.1/main
          </pre>
          in pg_hba.conf add the following line:
          <pre>
host all all 172.31.0.0/16 md5
          </pre>
          and in file postgresql.conf, change:
          <pre>
listen_addresses='localhost'
          </pre>
          to:
          <pre>
listen_addresses='*'
          </pre>
          <li>Configure PostgreSQL 9.1 to not require password for users</li><p>
            This can be used, e.g. to automate the creation of users by means of a script.
            Basically the following line has to be edited in the pg_hba.conf file:
            <pre>
local   all              all                                trust
            </pre>
            For full reproducibility here's the full <a href="postgresql.html.files/pg_hba.conf.html">pg_hba.conf</a> and the
            <a href="postgresql.html.files/postgresql.conf.html">postgresql.conf</a> configuration files.
            (the second doesn't play any part in this solution and is just provided for completeness
            purposes).
            <li>Configure PostgreSQL 9.1 to accept remote connections</li><p>
              <a href="http://www.cyberciti.biz/tips/postgres-allow-remote-access-tcp-connection.html">original article</a><p>
                It's a two step process:
                <ol type="i">
                  <li>enable client authentication</li>
                  Edit file /etc/postgresql/9.1/main/pg_hba.conf
                  and append the following configuration line to give access to the 192.168.2.0/24
                  network:
                  <pre>
host    all             all             192.168.2.0/24          md5
                  </pre>
                  <li>set the deamon to listen to the network interface</li>
                  Edit file /etc/postgresql/9.1/main/postgresql.conf and add the line:
                  <pre>
listen_addresses = '*'
                  </pre>
                  ... to listen to all the network interfaces.
                </ol>
                After the above steps do a:
                <pre>
sudo /etc/init.d/postgresql restart
                </pre>
                <li>Find Postgresql version</li>
<p>
                Connect as an existing user to an existing database and run the "select version()" query, or from the command line:
                <pre>
psql -Uhr -d ab -c 'select version()'
                </pre>
</p>
<p>&hellip; alternatively, if you don't know the passwords of any existing users but you have <tt>sudo</tt> privilleges, do:
<pre>sudo -u postgres psql postgres -c 'SELECT version()' | grep PostgreSQL
</pre>

</p>
  </ol>


</body>
